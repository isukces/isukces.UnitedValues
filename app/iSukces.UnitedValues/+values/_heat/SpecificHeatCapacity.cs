using System;
using System.Globalization;
using Newtonsoft.Json;
namespace iSukces.UnitedValues
{
    public partial struct SpecificHeatCapacity
    {
        public SpecificHeatCapacity(decimal value,
            EnergyUnit energy,
            MassUnit mass,
            KelvinTemperatureUnit temperature)
            : this(value, new EnergyMassDensityUnit(energy, mass), temperature)
        {
        }
    }
}

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: FractionValuesGenerator, UnitJsonConverterGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator

namespace iSukces.UnitedValues
{
    [Serializable]
    [JsonConverter(typeof(SpecificHeatCapacityJsonConverter))]
    public partial struct SpecificHeatCapacity : IUnitedValue<SpecificHeatCapacityUnit>, IEquatable<SpecificHeatCapacity>, IFormattable
    {
        /// <summary>
        /// creates instance of SpecificHeatCapacity
        /// </summary>
        /// <param name="value">value</param>
        /// <param name="unit">unit</param>
        public SpecificHeatCapacity(decimal value, SpecificHeatCapacityUnit unit)
        {
            Value = value;
            Unit = unit;
        }

        public SpecificHeatCapacity(decimal value, EnergyMassDensityUnit counterUnit, KelvinTemperatureUnit denominatorUnit)
        {
            Value = value;
            Unit = new SpecificHeatCapacityUnit(counterUnit, denominatorUnit);
        }

        public SpecificHeatCapacity ConvertTo(SpecificHeatCapacityUnit newUnit)
        {
            // generator : FractionValuesGenerator.Add_ConvertTo
            if (Unit.Equals(newUnit))
                return this;
            var a = new EnergyMassDensity(Value, Unit.CounterUnit);
            var b = new KelvinTemperature(1, Unit.DenominatorUnit);
            a = a.ConvertTo(newUnit.CounterUnit);
            b = b.ConvertTo(newUnit.DenominatorUnit);
            return new SpecificHeatCapacity(a.Value / b.Value, newUnit);
        }

        public bool Equals(SpecificHeatCapacity other)
        {
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public bool Equals(IUnitedValue<SpecificHeatCapacityUnit> other)
        {
            if (other is null)
                return false;
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public override bool Equals(object other)
        {
            return other is IUnitedValue<SpecificHeatCapacityUnit> unitedValue ? Equals(unitedValue) : false;
        }

        public decimal GetBaseUnitValue()
        {
            // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
            var factor1 = GlobalUnitRegistry.Factors.Get(Unit.CounterUnit);
            var factor2 = GlobalUnitRegistry.Factors.Get(Unit.DenominatorUnit);
            if ((factor1.HasValue && factor2.HasValue))
                return Value * factor1.Value / factor2.Value;
            throw new Exception("Unable to find multiplication for unit " + Unit);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Value.GetHashCode() * 397) ^ Unit?.GetHashCode() ?? 0;
            }
        }

        public SpecificHeatCapacity Round(int decimalPlaces)
        {
            return new SpecificHeatCapacity(Math.Round(Value, decimalPlaces), Unit);
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        /// <param name="format"></param>
        /// <param name="provider"></param>
        public string ToString(string format, IFormatProvider provider = null)
        {
            return this.ToStringFormat(format, provider);
        }

        public SpecificHeatCapacity WithCounterUnit(EnergyMassDensityUnit newUnit)
        {
            // generator : FractionValuesGenerator.Add_WithCounterUnit
            var oldUnit = Unit.CounterUnit;
            if (oldUnit == newUnit)
                return this;
            var oldFactor = GlobalUnitRegistry.Factors.GetThrow(oldUnit);
            var newFactor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
            var resultUnit = Unit.WithCounterUnit(newUnit);
            return new SpecificHeatCapacity(oldFactor / newFactor * Value, resultUnit);
        }

        public SpecificHeatCapacity WithDenominatorUnit(KelvinTemperatureUnit newUnit)
        {
            // generator : FractionValuesGenerator.Add_WithDenominatorUnit
            var oldUnit = Unit.DenominatorUnit;
            if (oldUnit == newUnit)
                return this;
            var oldFactor = GlobalUnitRegistry.Factors.GetThrow(oldUnit);
            var newFactor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
            var resultUnit = Unit.WithDenominatorUnit(newUnit);
            return new SpecificHeatCapacity(newFactor / oldFactor * Value, resultUnit);
        }

        /// <summary>
        /// Inequality operator
        /// </summary>
        /// <param name="left">first value to compare</param>
        /// <param name="right">second value to compare</param>
        public static bool operator !=(SpecificHeatCapacity left, SpecificHeatCapacity right)
        {
            return !left.Equals(right);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="deltaKelvinTemperature">left factor (multiplicand)</param>
        /// <param name="specificHeatCapacity">rigth factor (multiplier)</param>
        public static EnergyMassDensity operator *(DeltaKelvinTemperature deltaKelvinTemperature, SpecificHeatCapacity specificHeatCapacity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario B
            var unit = new SpecificHeatCapacityUnit(specificHeatCapacity.Unit.CounterUnit, deltaKelvinTemperature.Unit);
            var specificHeatCapacityConverted    = specificHeatCapacity.WithDenominatorUnit(deltaKelvinTemperature.Unit);
            var value = deltaKelvinTemperature.Value * specificHeatCapacityConverted.Value;
            return new EnergyMassDensity(value, specificHeatCapacity.Unit.CounterUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="specificHeatCapacity">left factor (multiplicand)</param>
        /// <param name="deltaKelvinTemperature">rigth factor (multiplier)</param>
        public static EnergyMassDensity operator *(SpecificHeatCapacity specificHeatCapacity, DeltaKelvinTemperature deltaKelvinTemperature)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // EnergyMassDensity operator *(SpecificHeatCapacity specificHeatCapacity, DeltaKelvinTemperature deltaKelvinTemperature)
            // scenario with hint
            // .Is<SpecificHeatCapacity, DeltaKelvinTemperature, EnergyMassDensity>("*")
            // hint location Add_EnergyMassDensity_DeltaKelvinTemperature_SpecificHeatCapacity, line 16
            var specificHeatCapacityUnit = specificHeatCapacity.Unit;
            var tmp1 = specificHeatCapacityUnit.CounterUnit;
            var resultUnit = new EnergyMassDensityUnit(tmp1.CounterUnit, tmp1.DenominatorUnit);
            var deltaKelvinTemperatureConverted = deltaKelvinTemperature.ConvertTo(specificHeatCapacityUnit.DenominatorUnit);
            var value = specificHeatCapacity.Value * deltaKelvinTemperatureConverted.Value;
            return new EnergyMassDensity(value, resultUnit);
            // scenario D1
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="deltaKelvinTemperature">left factor (multiplicand)</param>
        /// <param name="specificHeatCapacity">rigth factor (multiplier)</param>
        public static EnergyMassDensity? operator *(DeltaKelvinTemperature? deltaKelvinTemperature, SpecificHeatCapacity specificHeatCapacity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (deltaKelvinTemperature is null)
                return null;
            return deltaKelvinTemperature.Value * specificHeatCapacity;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="specificHeatCapacity">left factor (multiplicand)</param>
        /// <param name="deltaKelvinTemperature">rigth factor (multiplier)</param>
        public static EnergyMassDensity? operator *(SpecificHeatCapacity? specificHeatCapacity, DeltaKelvinTemperature deltaKelvinTemperature)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (specificHeatCapacity is null)
                return null;
            return specificHeatCapacity.Value * deltaKelvinTemperature;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="deltaKelvinTemperature">left factor (multiplicand)</param>
        /// <param name="specificHeatCapacity">rigth factor (multiplier)</param>
        public static EnergyMassDensity? operator *(DeltaKelvinTemperature deltaKelvinTemperature, SpecificHeatCapacity? specificHeatCapacity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (specificHeatCapacity is null)
                return null;
            return deltaKelvinTemperature * specificHeatCapacity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="specificHeatCapacity">left factor (multiplicand)</param>
        /// <param name="deltaKelvinTemperature">rigth factor (multiplier)</param>
        public static EnergyMassDensity? operator *(SpecificHeatCapacity specificHeatCapacity, DeltaKelvinTemperature? deltaKelvinTemperature)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (deltaKelvinTemperature is null)
                return null;
            return specificHeatCapacity * deltaKelvinTemperature.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="deltaKelvinTemperature">left factor (multiplicand)</param>
        /// <param name="specificHeatCapacity">rigth factor (multiplier)</param>
        public static EnergyMassDensity? operator *(DeltaKelvinTemperature? deltaKelvinTemperature, SpecificHeatCapacity? specificHeatCapacity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (deltaKelvinTemperature is null || specificHeatCapacity is null)
                return null;
            return deltaKelvinTemperature.Value * specificHeatCapacity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="specificHeatCapacity">left factor (multiplicand)</param>
        /// <param name="deltaKelvinTemperature">rigth factor (multiplier)</param>
        public static EnergyMassDensity? operator *(SpecificHeatCapacity? specificHeatCapacity, DeltaKelvinTemperature? deltaKelvinTemperature)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (specificHeatCapacity is null || deltaKelvinTemperature is null)
                return null;
            return specificHeatCapacity.Value * deltaKelvinTemperature.Value;
        }

        /// <summary>
        /// Equality operator
        /// </summary>
        /// <param name="left">first value to compare</param>
        /// <param name="right">second value to compare</param>
        public static bool operator ==(SpecificHeatCapacity left, SpecificHeatCapacity right)
        {
            return left.Equals(right);
        }

        public static SpecificHeatCapacity Parse(string value)
        {
            // generator : FractionValuesGenerator.Add_Parse
            throw new NotImplementedException("Not implemented due to unknown split method name.");
        }

        /// <summary>
        /// value
        /// </summary>
        public decimal Value { get; }

        /// <summary>
        /// unit
        /// </summary>
        public SpecificHeatCapacityUnit Unit { get; }

    }

    public partial class SpecificHeatCapacityJsonConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(SpecificHeatCapacityUnit);
        }

        /// <summary>
        /// Reads the JSON representation of the object.
        /// </summary>
        /// <param name="reader">The JsonReader to read from.</param>
        /// <param name="objectType">Type of the object.</param>
        /// <param name="existingValue">The existing value of object being read.</param>
        /// <param name="serializer">The calling serializer.</param>
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.ValueType == typeof(string))
            {
                if (objectType == typeof(SpecificHeatCapacity))
                    return SpecificHeatCapacity.Parse((string)reader.Value);
            }
            throw new NotImplementedException();
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value is null)
                writer.WriteNull();
            else
                writer.WriteValue(value.ToString());
        }

    }
}
