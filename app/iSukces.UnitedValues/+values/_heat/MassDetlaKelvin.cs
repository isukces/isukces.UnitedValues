using System;
using System.Globalization;
using Newtonsoft.Json;

namespace iSukces.UnitedValues;

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: ProductValuesGenerator, UnitJsonConverterGenerator
[Serializable]
[JsonConverter(typeof(MassDetlaKelvinJsonConverter))]
public partial struct MassDetlaKelvin : IUnitedValue<MassDetlaKelvinUnit>, IEquatable<MassDetlaKelvin>, IFormattable
{
    /// <summary>
    /// creates instance of MassDetlaKelvin
    /// </summary>
    /// <param name="value">value</param>
    /// <param name="unit">unit</param>
    public MassDetlaKelvin(decimal value, MassDetlaKelvinUnit unit)
    {
        Value = value;
        Unit = unit;
    }

    public MassDetlaKelvin(decimal value, MassUnit leftUnit, KelvinTemperatureUnit rightUnit)
    {
        Value = value;
        Unit = new MassDetlaKelvinUnit(leftUnit, rightUnit);
    }

    public MassDetlaKelvin ConvertTo(MassDetlaKelvinUnit newUnit)
    {
        // generator : ProductValuesGenerator.Add_ConvertTo
        if (Unit.Equals(newUnit))
            return this;
        var a = new Mass(Value, Unit.LeftUnit);
        var b = new DeltaKelvinTemperature(1, Unit.RightUnit);
        a = a.ConvertTo(newUnit.LeftUnit);
        b = b.ConvertTo(newUnit.RightUnit);
        return new MassDetlaKelvin(a.Value / b.Value, newUnit);
    }

    public bool Equals(MassDetlaKelvin other)
    {
        // generator : ProductValuesGenerator
        return Value == other.Value && Unit is not null && Unit.Equals(other.Unit);
    }

    public bool Equals(IUnitedValue<MassDetlaKelvinUnit>? other)
    {
        // generator : ProductValuesGenerator
        if (other is null)
            return false;
        return Value == other.Value && Unit is not null && Unit.Equals(other.Unit);
    }

    public override bool Equals(object? other)
    {
        // generator : ProductValuesGenerator
        return other is IUnitedValue<MassDetlaKelvinUnit> value && Equals(value);
    }

    public decimal GetBaseUnitValue()
    {
        // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
        var factor1 = GlobalUnitRegistry.Factors.Get(Unit.LeftUnit);
        var factor2 = GlobalUnitRegistry.Factors.Get(Unit.RightUnit);
        if ((factor1.HasValue && factor2.HasValue))
            return Value * factor1.Value * factor2.Value;
        throw new Exception("Unable to find multiplication for unit " + Unit);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
        }
    }

    public MassDetlaKelvin Round(int decimalPlaces)
    {
        return new MassDetlaKelvin(Math.Round(Value, decimalPlaces), Unit);
    }

    public string SerializeToJson()
    {
        // generator : ProductValuesGenerator.Add_SerializeToJson
        var l = Unit.LeftUnit.UnitName ?? string.Empty;
        var r = Unit.RightUnit.UnitName ?? string.Empty;
        if (l.Length==1 && r.Length==1)
            return ToString();
        return Value.ToString(CultureInfo.InvariantCulture) + l + Common.TimesSign + r;
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    public override string ToString()
    {
        return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    /// <param name="format"></param>
    /// <param name="provider"></param>
    public string ToString(string format, IFormatProvider provider = null)
    {
        return this.ToStringFormat(format, provider);
    }

    public MassDetlaKelvin WithLeftUnit(MassUnit newUnit)
    {
        // generator : ProductValuesGenerator.Add_WithCounterUnit
        var oldUnit = Unit.LeftUnit;
        if (oldUnit == newUnit)
            return this;
        var oldFactor = GlobalUnitRegistry.Factors.GetThrow(oldUnit);
        var newFactor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
        var resultUnit = Unit.WithLeftUnit(newUnit);
        return new MassDetlaKelvin(oldFactor / newFactor * Value, resultUnit);
    }

    public MassDetlaKelvin WithRightUnit(KelvinTemperatureUnit newUnit)
    {
        // generator : ProductValuesGenerator.Add_WithDenominatorUnit
        var oldUnit = Unit.RightUnit;
        if (oldUnit == newUnit)
            return this;
        var oldFactor = GlobalUnitRegistry.Factors.GetThrow(oldUnit);
        var newFactor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
        var resultUnit = Unit.WithRightUnit(newUnit);
        return new MassDetlaKelvin(newFactor / oldFactor * Value, resultUnit);
    }

    /// <summary>
    /// Inequality operator
    /// </summary>
    /// <param name="left">first value to compare</param>
    /// <param name="right">second value to compare</param>
    public static bool operator !=(MassDetlaKelvin left, MassDetlaKelvin right)
    {
        return !left.Equals(right);
    }

    /// <summary>
    /// Equality operator
    /// </summary>
    /// <param name="left">first value to compare</param>
    /// <param name="right">second value to compare</param>
    public static bool operator ==(MassDetlaKelvin left, MassDetlaKelvin right)
    {
        return left.Equals(right);
    }

    public static MassDetlaKelvin Parse(string value)
    {
        // generator : ProductValuesGenerator.Add_Parse
        if (string.IsNullOrEmpty(value))
            throw new ArgumentNullException(nameof(value));
        var r = CommonParse.Parse(value, typeof(MassDetlaKelvin));
        var units = Common.SplitUnitNameByTimesSign(r.UnitName);
        if (units.Length != 2)
            throw new Exception($"{r.UnitName} is not valid MassDetlaKelvin unit");
        var counterUnit = new MassUnit(units[0]);
        var denominatorUnit = new KelvinTemperatureUnit(units[1]);
        return new MassDetlaKelvin(r.Value, counterUnit, denominatorUnit);
    }

    /// <summary>
    /// value
    /// </summary>
    public decimal Value { get; }

    /// <summary>
    /// unit
    /// </summary>
    public MassDetlaKelvinUnit Unit { get; }

}

public partial class MassDetlaKelvinJsonConverter : JsonConverter
{
    public override bool CanConvert(Type objectType)
    {
        return objectType == typeof(MassDetlaKelvinUnit);
    }

    /// <summary>
    /// Reads the JSON representation of the object.
    /// </summary>
    /// <param name="reader">The JsonReader to read from.</param>
    /// <param name="objectType">Type of the object.</param>
    /// <param name="existingValue">The existing value of object being read.</param>
    /// <param name="serializer">The calling serializer.</param>
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
    {
        if (reader.ValueType == typeof(string))
        {
            if (objectType == typeof(MassDetlaKelvin))
                return MassDetlaKelvin.Parse((string)reader.Value);
        }
        throw new NotImplementedException();
    }

    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
    {
        if (value is null)
            writer.WriteNull();
        else
            writer.WriteValue(((MassDetlaKelvin)value).SerializeToJson());
    }

}
