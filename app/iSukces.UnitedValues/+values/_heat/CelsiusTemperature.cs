using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;

namespace iSukces.UnitedValues;

public partial struct CelsiusTemperature
{
    public static string MakeMessage<T>(IUnitedValue<T> temp, string a, string b)
        where T : IUnit, IEquatable<T>
    {
        return $"Unable to convert {a} in {temp.Unit} into {b}.";
    }

    public static implicit operator CelsiusTemperature(KelvinTemperature temp)
    {
        if (temp.Unit == KelvinTemperatureUnits.Degree)
            return FromDegree(temp.Value + AbsoluteZeroValue);
        throw new NotSupportedException(
            MakeMessage(temp, Kelvin, Celsius));
    }

    public static implicit operator KelvinTemperature(CelsiusTemperature temp)
    {
        if (temp.Unit == CelsiusTemperatureUnits.Degree)
            return FromDegree(temp.Value - AbsoluteZeroValue);
        throw new NotSupportedException(
            MakeMessage(temp, Celsius, Kelvin));
    }

    public static CelsiusTemperature AbsoluteZero = FromDegree(AbsoluteZeroValue);
    private const string             Celsius      = "Celsius temperature";
    private const string             Kelvin       = "Kelvin temperature";

    private const decimal AbsoluteZeroValue = -273.15m;
}

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: BasicUnitValuesGenerator, UnitJsonConverterGenerator, UnitExtensionsGenerator
[Serializable]
[JsonConverter(typeof(CelsiusTemperatureJsonConverter))]
public partial struct CelsiusTemperature : IUnitedValue<CelsiusTemperatureUnit>, IEquatable<CelsiusTemperature>, IComparable<CelsiusTemperature>, IFormattable
{
    /// <summary>
    /// creates instance of CelsiusTemperature
    /// </summary>
    /// <param name="value">value</param>
    /// <param name="unit">unit</param>
    public CelsiusTemperature(decimal value, CelsiusTemperatureUnit unit)
    {
        Value = value;
        if (unit is null)
            throw new NullReferenceException(nameof(unit));
        _unit = unit;
    }

    public int CompareTo(CelsiusTemperature other)
    {
        return UnitedValuesUtils.Compare<CelsiusTemperature, CelsiusTemperatureUnit>(this, other);
    }

    public CelsiusTemperature ConvertTo(CelsiusTemperatureUnit newUnit)
    {
        // generator : BasicUnitValuesGenerator.Add_ConvertTo
        if (Unit.Equals(newUnit))
            return this;
        var basic = GetBaseUnitValue();
        var factor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
        return new CelsiusTemperature(basic / factor, newUnit);
    }

    public bool Equals(CelsiusTemperature other)
    {
        return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
    }

    public bool Equals(IUnitedValue<CelsiusTemperatureUnit> other)
    {
        if (other is null)
            return false;
        return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
    }

    public override bool Equals(object other)
    {
        return other is IUnitedValue<CelsiusTemperatureUnit> unitedValue ? Equals(unitedValue) : false;
    }

    public decimal GetBaseUnitValue()
    {
        // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
        if (Unit.Equals(BaseUnit))
            return Value;
        var factor = GlobalUnitRegistry.Factors.Get(Unit);
        if (!(factor is null))
            return Value * factor.Value;
        throw new Exception("Unable to find multiplication for unit " + Unit);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
        }
    }

    public CelsiusTemperature Round(int decimalPlaces)
    {
        return new CelsiusTemperature(Math.Round(Value, decimalPlaces), Unit);
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    public override string ToString()
    {
        return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    /// <param name="format"></param>
    /// <param name="provider"></param>
    public string ToString(string format, IFormatProvider provider = null)
    {
        return this.ToStringFormat(format, provider);
    }

    /// <summary>
    /// implements - operator
    /// </summary>
    /// <param name="value"></param>
    public static CelsiusTemperature operator -(CelsiusTemperature value)
    {
        return new CelsiusTemperature(-value.Value, value.Unit);
    }

    public static DeltaCelsiusTemperature operator -(CelsiusTemperature left, CelsiusTemperature right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return new DeltaCelsiusTemperature(-right.Value, right.Unit);
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return new DeltaCelsiusTemperature(left.Value, left.Unit);
        right = right.ConvertTo(left.Unit);
        return new DeltaCelsiusTemperature(left.Value - right.Value, left.Unit);
    }

    public static bool operator !=(CelsiusTemperature left, CelsiusTemperature right)
    {
        return left.CompareTo(right) != 0;
    }

    /// <summary>
    /// implements * operator
    /// </summary>
    /// <param name="value"></param>
    /// <param name="number"></param>
    public static CelsiusTemperature operator *(CelsiusTemperature value, decimal number)
    {
        return new CelsiusTemperature(value.Value * number, value.Unit);
    }

    /// <summary>
    /// implements * operator
    /// </summary>
    /// <param name="number"></param>
    /// <param name="value"></param>
    public static CelsiusTemperature operator *(decimal number, CelsiusTemperature value)
    {
        return new CelsiusTemperature(value.Value * number, value.Unit);
    }

    /// <summary>
    /// implements / operator
    /// </summary>
    /// <param name="value"></param>
    /// <param name="number"></param>
    public static CelsiusTemperature operator /(CelsiusTemperature value, decimal number)
    {
        return new CelsiusTemperature(value.Value / number, value.Unit);
    }

    public static decimal operator /(CelsiusTemperature left, CelsiusTemperature right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_MulDiv
        right = right.ConvertTo(left.Unit);
        return left.Value / right.Value;
    }

    public static CelsiusTemperature operator +(CelsiusTemperature left, DeltaCelsiusTemperature right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return new CelsiusTemperature(right.Value, left.Unit);
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return left;
        right = right.ConvertTo(left.Unit);
        return new CelsiusTemperature(left.Value + right.Value, left.Unit);
    }

    public static CelsiusTemperature operator +(DeltaCelsiusTemperature left, CelsiusTemperature right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return right;
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return new CelsiusTemperature(left.Value, right.Unit);
        right = right.ConvertTo(left.Unit);
        return new CelsiusTemperature(left.Value + right.Value, left.Unit);
    }

    public static bool operator <(CelsiusTemperature left, CelsiusTemperature right)
    {
        return left.CompareTo(right) < 0;
    }

    public static bool operator <=(CelsiusTemperature left, CelsiusTemperature right)
    {
        return left.CompareTo(right) <= 0;
    }

    public static bool operator ==(CelsiusTemperature left, CelsiusTemperature right)
    {
        return left.CompareTo(right) == 0;
    }

    public static bool operator >(CelsiusTemperature left, CelsiusTemperature right)
    {
        return left.CompareTo(right) > 0;
    }

    public static bool operator >=(CelsiusTemperature left, CelsiusTemperature right)
    {
        return left.CompareTo(right) >= 0;
    }

    /// <summary>
    /// creates celsiusTemperature from value in °C
    /// </summary>
    /// <param name="value">CelsiusTemperature value in °C</param>
    public static CelsiusTemperature FromDegree(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new CelsiusTemperature(value, CelsiusTemperatureUnits.Degree);
    }

    /// <summary>
    /// creates celsiusTemperature from value in °C
    /// </summary>
    /// <param name="value">CelsiusTemperature value in °C</param>
    public static CelsiusTemperature FromDegree(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new CelsiusTemperature((decimal)value, CelsiusTemperatureUnits.Degree);
    }

    /// <summary>
    /// creates celsiusTemperature from value in °C
    /// </summary>
    /// <param name="value">CelsiusTemperature value in °C</param>
    public static CelsiusTemperature FromDegree(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new CelsiusTemperature(value, CelsiusTemperatureUnits.Degree);
    }

    /// <summary>
    /// creates celsiusTemperature from value in °C
    /// </summary>
    /// <param name="value">CelsiusTemperature value in °C</param>
    public static CelsiusTemperature FromDegree(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new CelsiusTemperature(value, CelsiusTemperatureUnits.Degree);
    }

    public static CelsiusTemperature Parse(string value)
    {
        // generator : BasicUnitValuesGenerator.Add_Parse
        var parseResult = CommonParse.Parse(value, typeof(CelsiusTemperature));
        if (string.IsNullOrEmpty(parseResult.UnitName))
            return new CelsiusTemperature(parseResult.Value, CelsiusTemperature.BaseUnit);
        return new CelsiusTemperature(parseResult.Value, new CelsiusTemperatureUnit(parseResult.UnitName));
    }

    /// <summary>
    /// value
    /// </summary>
    public decimal Value { get; }

    /// <summary>
    /// unit
    /// </summary>
    [JetBrains.Annotations.NotNull]
    public CelsiusTemperatureUnit Unit
    {
        get { return _unit ?? BaseUnit; }
    }

    private CelsiusTemperatureUnit _unit;

    public static readonly CelsiusTemperatureUnit BaseUnit = CelsiusTemperatureUnits.Degree;

    public static readonly CelsiusTemperature Zero = new CelsiusTemperature(0, BaseUnit);

}

public static partial class CelsiusTemperatureExtensions
{
    public static CelsiusTemperature Sum(this IEnumerable<CelsiusTemperature> items)
    {
        if (items is null)
            return CelsiusTemperature.Zero;
        var c = items.ToArray();
        if (c.Length == 0)
            return CelsiusTemperature.Zero;
        if (c.Length == 1)
            return c[0];
        var unit  = c[0].Unit;
        var value = c.Aggregate(0m, (x, y) => x + y.ConvertTo(unit).Value);
        return new CelsiusTemperature(value, unit);
    }

    public static CelsiusTemperature Sum(this IEnumerable<CelsiusTemperature?> items)
    {
        if (items is null)
            return CelsiusTemperature.Zero;
        return items.Where(a => a != null).Select(a => a.Value).Sum();
    }

    public static CelsiusTemperature Sum<T>(this IEnumerable<T> items, Func<T, CelsiusTemperature> map)
    {
        if (items is null)
            return CelsiusTemperature.Zero;
        return items.Select(map).Sum();
    }

}

public partial class CelsiusTemperatureJsonConverter : AbstractUnitJsonConverter<CelsiusTemperature, CelsiusTemperatureUnit>
{
    protected override CelsiusTemperature Make(decimal value, string unit)
    {
        unit = unit?.Trim();
        return new CelsiusTemperature(value, string.IsNullOrEmpty(unit) ? CelsiusTemperature.BaseUnit : new CelsiusTemperatureUnit(unit));
    }

    protected override CelsiusTemperature Parse(string txt)
    {
        return CelsiusTemperature.Parse(txt);
    }

}
