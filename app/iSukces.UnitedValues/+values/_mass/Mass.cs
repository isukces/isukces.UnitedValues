using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;

namespace iSukces.UnitedValues;

public partial struct Mass
{
    public Mass ConvertToKg()
    {
        return ConvertTo(MassUnits.Kg);
    }

    public Mass RoundKg(int decimalPlaces)
    {
        var w = ConvertToKg();
        return FromKg(Math.Round(w.Value, decimalPlaces));
    }
}

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: BasicUnitValuesGenerator, UnitJsonConverterGenerator, UnitExtensionsGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator
[Serializable]
[JsonConverter(typeof(MassJsonConverter))]
public partial struct Mass : IUnitedValue<MassUnit>, IEquatable<Mass>, IComparable<Mass>, IFormattable
{
    /// <summary>
    /// creates instance of Mass
    /// </summary>
    /// <param name="value">value</param>
    /// <param name="unit">unit</param>
    public Mass(decimal value, MassUnit unit)
    {
        Value = value;
        if (unit is null)
            throw new NullReferenceException(nameof(unit));
        _unit = unit;
    }

    public int CompareTo(Mass other)
    {
        return UnitedValuesUtils.Compare<Mass, MassUnit>(this, other);
    }

    public Mass ConvertTo(MassUnit newUnit)
    {
        // generator : BasicUnitValuesGenerator.Add_ConvertTo
        if (Unit.Equals(newUnit))
            return this;
        var basic = GetBaseUnitValue();
        var factor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
        return new Mass(basic / factor, newUnit);
    }

    public bool Equals(Mass other)
    {
        // generator : BasicUnitValuesGenerator
        return Value == other.Value && Unit is not null && Unit.Equals(other.Unit);
    }

    public bool Equals(IUnitedValue<MassUnit>? other)
    {
        // generator : BasicUnitValuesGenerator
        if (other is null)
            return false;
        return Value == other.Value && Unit is not null && Unit.Equals(other.Unit);
    }

    public override bool Equals(object? other)
    {
        // generator : BasicUnitValuesGenerator
        return other is IUnitedValue<MassUnit> value && Equals(value);
    }

    public decimal GetBaseUnitValue()
    {
        // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
        if (Unit.Equals(BaseUnit))
            return Value;
        var factor = GlobalUnitRegistry.Factors.Get(Unit);
        if (factor is not null)
            return Value * factor.Value;
        throw new Exception("Unable to find multiplication for unit " + Unit);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
        }
    }

    public Mass Round(int decimalPlaces)
    {
        return new Mass(Math.Round(Value, decimalPlaces), Unit);
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    public override string ToString()
    {
        return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    /// <param name="format"></param>
    /// <param name="provider"></param>
    public string ToString(string? format, IFormatProvider? provider = null)
    {
        return this.ToStringFormat(format, provider);
    }

    /// <summary>
    /// creates mass from value in g
    /// </summary>
    /// <param name="value">Mass value in g</param>
    public static Mass FromGrams(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Gram);
    }

    /// <summary>
    /// creates mass from value in g
    /// </summary>
    /// <param name="value">Mass value in g</param>
    public static Mass FromGrams(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass((decimal)value, MassUnits.Gram);
    }

    /// <summary>
    /// creates mass from value in g
    /// </summary>
    /// <param name="value">Mass value in g</param>
    public static Mass FromGrams(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Gram);
    }

    /// <summary>
    /// creates mass from value in g
    /// </summary>
    /// <param name="value">Mass value in g</param>
    public static Mass FromGrams(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Gram);
    }

    /// <summary>
    /// creates mass from value in kg
    /// </summary>
    /// <param name="value">Mass value in kg</param>
    public static Mass FromKg(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Kg);
    }

    /// <summary>
    /// creates mass from value in kg
    /// </summary>
    /// <param name="value">Mass value in kg</param>
    public static Mass FromKg(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass((decimal)value, MassUnits.Kg);
    }

    /// <summary>
    /// creates mass from value in kg
    /// </summary>
    /// <param name="value">Mass value in kg</param>
    public static Mass FromKg(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Kg);
    }

    /// <summary>
    /// creates mass from value in kg
    /// </summary>
    /// <param name="value">Mass value in kg</param>
    public static Mass FromKg(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Kg);
    }

    /// <summary>
    /// creates mass from value in oz
    /// </summary>
    /// <param name="value">Mass value in oz</param>
    public static Mass FromOunce(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Ounce);
    }

    /// <summary>
    /// creates mass from value in oz
    /// </summary>
    /// <param name="value">Mass value in oz</param>
    public static Mass FromOunce(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass((decimal)value, MassUnits.Ounce);
    }

    /// <summary>
    /// creates mass from value in oz
    /// </summary>
    /// <param name="value">Mass value in oz</param>
    public static Mass FromOunce(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Ounce);
    }

    /// <summary>
    /// creates mass from value in oz
    /// </summary>
    /// <param name="value">Mass value in oz</param>
    public static Mass FromOunce(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Ounce);
    }

    /// <summary>
    /// creates mass from value in lbs
    /// </summary>
    /// <param name="value">Mass value in lbs</param>
    public static Mass FromPound(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Pound);
    }

    /// <summary>
    /// creates mass from value in lbs
    /// </summary>
    /// <param name="value">Mass value in lbs</param>
    public static Mass FromPound(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass((decimal)value, MassUnits.Pound);
    }

    /// <summary>
    /// creates mass from value in lbs
    /// </summary>
    /// <param name="value">Mass value in lbs</param>
    public static Mass FromPound(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Pound);
    }

    /// <summary>
    /// creates mass from value in lbs
    /// </summary>
    /// <param name="value">Mass value in lbs</param>
    public static Mass FromPound(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Pound);
    }

    /// <summary>
    /// creates mass from value in t
    /// </summary>
    /// <param name="value">Mass value in t</param>
    public static Mass FromTons(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Tone);
    }

    /// <summary>
    /// creates mass from value in t
    /// </summary>
    /// <param name="value">Mass value in t</param>
    public static Mass FromTons(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass((decimal)value, MassUnits.Tone);
    }

    /// <summary>
    /// creates mass from value in t
    /// </summary>
    /// <param name="value">Mass value in t</param>
    public static Mass FromTons(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Tone);
    }

    /// <summary>
    /// creates mass from value in t
    /// </summary>
    /// <param name="value">Mass value in t</param>
    public static Mass FromTons(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.Tone);
    }

    /// <summary>
    /// creates mass from value in oz t
    /// </summary>
    /// <param name="value">Mass value in oz t</param>
    public static Mass FromTroyOunce(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.TroyOunce);
    }

    /// <summary>
    /// creates mass from value in oz t
    /// </summary>
    /// <param name="value">Mass value in oz t</param>
    public static Mass FromTroyOunce(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass((decimal)value, MassUnits.TroyOunce);
    }

    /// <summary>
    /// creates mass from value in oz t
    /// </summary>
    /// <param name="value">Mass value in oz t</param>
    public static Mass FromTroyOunce(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.TroyOunce);
    }

    /// <summary>
    /// creates mass from value in oz t
    /// </summary>
    /// <param name="value">Mass value in oz t</param>
    public static Mass FromTroyOunce(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Mass(value, MassUnits.TroyOunce);
    }

    public static Mass Parse(string value)
    {
        // generator : BasicUnitValuesGenerator.Add_Parse
        var parseResult = CommonParse.Parse(value, typeof(Mass));
        if (string.IsNullOrEmpty(parseResult.UnitName))
            return new Mass(parseResult.Value, Mass.BaseUnit);
        return new Mass(parseResult.Value, new MassUnit(parseResult.UnitName));
    }

    public static Mass operator +(Mass left, Mass right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return right;
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return left;
        right = right.ConvertTo(left.Unit);
        return new Mass(left.Value + right.Value, left.Unit);
    }

    /// <summary>
    /// implements - operator
    /// </summary>
    /// <param name="value"></param>
    public static Mass operator -(Mass value)
    {
        return new Mass(-value.Value, value.Unit);
    }

    public static Mass operator -(Mass left, Mass right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return -right;
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return left;
        right = right.ConvertTo(left.Unit);
        return new Mass(left.Value - right.Value, left.Unit);
    }

    /// <summary>
    /// implements * operator
    /// </summary>
    /// <param name="value"></param>
    /// <param name="number"></param>
    public static Mass operator *(Mass value, decimal number)
    {
        return new Mass(value.Value * number, value.Unit);
    }

    /// <summary>
    /// implements * operator
    /// </summary>
    /// <param name="number"></param>
    /// <param name="value"></param>
    public static Mass operator *(decimal number, Mass value)
    {
        return new Mass(value.Value * number, value.Unit);
    }

    /// <summary>
    /// implements / operator
    /// </summary>
    /// <param name="value"></param>
    /// <param name="number"></param>
    public static Mass operator /(Mass value, decimal number)
    {
        return new Mass(value.Value / number, value.Unit);
    }

    public static decimal operator /(Mass left, Mass right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_MulDiv
        right = right.ConvertTo(left.Unit);
        return left.Value / right.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearDensity operator /(Mass mass, Length length)
    {
        // generator : MultiplyAlgebraGenerator.CreateOperator
        // scenario with hint
        // .Is<Mass, Length, LinearDensity>("/")
        // hint location GetBasicOperatorHints, line 31
        var resultUnit = new LinearDensityUnit(mass.Unit, length.Unit);
        var value = mass.Value / length.Value;
        return new LinearDensity(value, resultUnit);
        // scenario F3
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length operator /(Mass mass, LinearDensity linearDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
        // scenario A
        // lineardensity unit will be synchronized with mass unit
        var unit = new LinearDensityUnit(mass.Unit, linearDensity.Unit.DenominatorUnit);
        var linearDensityConverted    = linearDensity.WithCounterUnit(mass.Unit);
        var value = mass.Value / linearDensityConverted.Value;
        return new Length(value, linearDensity.Unit.DenominatorUnit);
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearDensity? operator /(Mass? mass, Length length)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null)
            return null;
        return mass.Value / length;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length? operator /(Mass? mass, LinearDensity linearDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null)
            return null;
        return mass.Value / linearDensity;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearDensity? operator /(Mass mass, Length? length)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (length is null)
            return null;
        return mass / length.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length? operator /(Mass mass, LinearDensity? linearDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (linearDensity is null)
            return null;
        return mass / linearDensity.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearDensity? operator /(Mass? mass, Length? length)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null || length is null)
            return null;
        return mass.Value / length.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length? operator /(Mass? mass, LinearDensity? linearDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null || linearDensity is null)
            return null;
        return mass.Value / linearDensity.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static PlanarDensity operator /(Mass mass, Area area)
    {
        // generator : MultiplyAlgebraGenerator.CreateOperator
        // scenario with hint
        // .Is<Mass, Area, PlanarDensity>("/")
        // hint location GetBasicOperatorHints, line 31
        var resultUnit = new PlanarDensityUnit(mass.Unit, area.Unit);
        var value = mass.Value / area.Value;
        return new PlanarDensity(value, resultUnit);
        // scenario F3
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="planarDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area operator /(Mass mass, PlanarDensity planarDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
        // scenario A
        // planardensity unit will be synchronized with mass unit
        var unit = new PlanarDensityUnit(mass.Unit, planarDensity.Unit.DenominatorUnit);
        var planarDensityConverted    = planarDensity.WithCounterUnit(mass.Unit);
        var value = mass.Value / planarDensityConverted.Value;
        return new Area(value, planarDensity.Unit.DenominatorUnit);
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static PlanarDensity? operator /(Mass? mass, Area area)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null)
            return null;
        return mass.Value / area;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="planarDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area? operator /(Mass? mass, PlanarDensity planarDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null)
            return null;
        return mass.Value / planarDensity;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static PlanarDensity? operator /(Mass mass, Area? area)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (area is null)
            return null;
        return mass / area.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="planarDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area? operator /(Mass mass, PlanarDensity? planarDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (planarDensity is null)
            return null;
        return mass / planarDensity.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static PlanarDensity? operator /(Mass? mass, Area? area)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null || area is null)
            return null;
        return mass.Value / area.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="planarDensity">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area? operator /(Mass? mass, PlanarDensity? planarDensity)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null || planarDensity is null)
            return null;
        return mass.Value / planarDensity.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="volume">a divisor (denominator) - a value which dividend is divided by</param>
    public static Density operator /(Mass mass, Volume volume)
    {
        // generator : MultiplyAlgebraGenerator.CreateOperator
        // scenario with hint
        // .Is<Mass, Volume, Density>("/")
        // hint location GetBasicOperatorHints, line 31
        var resultUnit = new DensityUnit(mass.Unit, volume.Unit);
        var value = mass.Value / volume.Value;
        return new Density(value, resultUnit);
        // scenario F3
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="density">a divisor (denominator) - a value which dividend is divided by</param>
    public static Volume operator /(Mass mass, Density density)
    {
        // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
        // scenario A
        // density unit will be synchronized with mass unit
        var unit = new DensityUnit(mass.Unit, density.Unit.DenominatorUnit);
        var densityConverted    = density.WithCounterUnit(mass.Unit);
        var value = mass.Value / densityConverted.Value;
        return new Volume(value, density.Unit.DenominatorUnit);
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="volume">a divisor (denominator) - a value which dividend is divided by</param>
    public static Density? operator /(Mass? mass, Volume volume)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null)
            return null;
        return mass.Value / volume;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="density">a divisor (denominator) - a value which dividend is divided by</param>
    public static Volume? operator /(Mass? mass, Density density)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null)
            return null;
        return mass.Value / density;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="volume">a divisor (denominator) - a value which dividend is divided by</param>
    public static Density? operator /(Mass mass, Volume? volume)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (volume is null)
            return null;
        return mass / volume.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="density">a divisor (denominator) - a value which dividend is divided by</param>
    public static Volume? operator /(Mass mass, Density? density)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (density is null)
            return null;
        return mass / density.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="volume">a divisor (denominator) - a value which dividend is divided by</param>
    public static Density? operator /(Mass? mass, Volume? volume)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null || volume is null)
            return null;
        return mass.Value / volume.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="mass">a dividend (counter) - a value that is being divided</param>
    /// <param name="density">a divisor (denominator) - a value which dividend is divided by</param>
    public static Volume? operator /(Mass? mass, Density? density)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (mass is null || density is null)
            return null;
        return mass.Value / density.Value;
    }

    public static bool operator ==(Mass left, Mass right)
    {
        return left.CompareTo(right) == 0;
    }

    public static bool operator !=(Mass left, Mass right)
    {
        return left.CompareTo(right) != 0;
    }

    public static bool operator <(Mass left, Mass right)
    {
        return left.CompareTo(right) < 0;
    }

    public static bool operator <=(Mass left, Mass right)
    {
        return left.CompareTo(right) <= 0;
    }

    public static bool operator >(Mass left, Mass right)
    {
        return left.CompareTo(right) > 0;
    }

    public static bool operator >=(Mass left, Mass right)
    {
        return left.CompareTo(right) >= 0;
    }

    /// <summary>
    /// value
    /// </summary>
    public decimal Value { get; }

    /// <summary>
    /// unit
    /// </summary>
    public MassUnit Unit => _unit ?? BaseUnit;

    private MassUnit _unit;

    public static readonly MassUnit BaseUnit = MassUnits.Kg;

    public static readonly Mass Zero = new Mass(0, BaseUnit);

}

public static partial class MassExtensions
{
    public static Mass Sum(this IEnumerable<Mass> items)
    {
        if (items is null)
            return Mass.Zero;
        var c = items.ToArray();
        if (c.Length == 0)
            return Mass.Zero;
        if (c.Length == 1)
            return c[0];
        var unit  = c[0].Unit;
        var value = c.Aggregate(0m, (x, y) => x + y.ConvertTo(unit).Value);
        return new Mass(value, unit);
    }

    public static Mass Sum(this IEnumerable<Mass?> items)
    {
        if (items is null)
            return Mass.Zero;
        return items.Where(a => a != null).Select(a => a!.Value).Sum();
    }

    public static Mass Sum<T>(this IEnumerable<T> items, Func<T, Mass> map)
    {
        if (items is null)
            return Mass.Zero;
        return items.Select(map).Sum();
    }

}

public partial class MassJsonConverter : AbstractUnitJsonConverter<Mass, MassUnit>
{
    protected override Mass Make(decimal value, string? unit)
    {
        unit = unit?.Trim();
        return new Mass(value, string.IsNullOrEmpty(unit) ? Mass.BaseUnit : new MassUnit(unit));
    }

    protected override Mass Parse(string txt)
    {
        return Mass.Parse(txt);
    }

}
