using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;

namespace iSukces.UnitedValues
{
    public partial struct Time
    {
        public const decimal DaysPerYear   = 365.242199m;
        public const decimal SecondsPerDay = 24m * 3600m;
        public const decimal SecondsPerYear = DaysPerYear * SecondsPerDay;
    }
}

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: BasicUnitValuesGenerator, UnitJsonConverterGenerator, UnitExtensionsGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator

namespace iSukces.UnitedValues
{
    [Serializable]
    [JsonConverter(typeof(TimeJsonConverter))]
    public partial struct Time : IUnitedValue<TimeUnit>, IEquatable<Time>, IComparable<Time>, IFormattable
    {
        /// <summary>
        /// creates instance of Time
        /// </summary>
        /// <param name="value">value</param>
        /// <param name="unit">unit</param>
        public Time(decimal value, TimeUnit unit)
        {
            Value = value;
            if (unit is null)
                throw new NullReferenceException(nameof(unit));
            _unit = unit;
        }

        public int CompareTo(Time other)
        {
            return UnitedValuesUtils.Compare<Time, TimeUnit>(this, other);
        }

        public Time ConvertTo(TimeUnit newUnit)
        {
            // generator : BasicUnitValuesGenerator.Add_ConvertTo
            if (Unit.Equals(newUnit))
                return this;
            var basic = GetBaseUnitValue();
            var factor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
            return new Time(basic / factor, newUnit);
        }

        public bool Equals(Time other)
        {
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public bool Equals(IUnitedValue<TimeUnit> other)
        {
            if (other is null)
                return false;
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public override bool Equals(object other)
        {
            return other is IUnitedValue<TimeUnit> unitedValue ? Equals(unitedValue) : false;
        }

        public decimal GetBaseUnitValue()
        {
            // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
            if (Unit.Equals(BaseUnit))
                return Value;
            var factor = GlobalUnitRegistry.Factors.Get(Unit);
            if (!(factor is null))
                return Value * factor.Value;
            throw new Exception("Unable to find multiplication for unit " + Unit);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
            }
        }

        public Time Round(int decimalPlaces)
        {
            return new Time(Math.Round(Value, decimalPlaces), Unit);
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        /// <param name="format"></param>
        /// <param name="provider"></param>
        public string ToString(string format, IFormatProvider provider = null)
        {
            return this.ToStringFormat(format, provider);
        }

        /// <summary>
        /// implements - operator
        /// </summary>
        /// <param name="value"></param>
        public static Time operator -(Time value)
        {
            return new Time(-value.Value, value.Unit);
        }

        public static Time operator -(Time left, Time right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
            if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
                return -right;
            if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
                return left;
            right = right.ConvertTo(left.Unit);
            return new Time(left.Value - right.Value, left.Unit);
        }

        public static bool operator !=(Time left, Time right)
        {
            return left.CompareTo(right) != 0;
        }

        /// <summary>
        /// implements * operator
        /// </summary>
        /// <param name="value"></param>
        /// <param name="number"></param>
        public static Time operator *(Time value, decimal number)
        {
            return new Time(value.Value * number, value.Unit);
        }

        /// <summary>
        /// implements * operator
        /// </summary>
        /// <param name="number"></param>
        /// <param name="value"></param>
        public static Time operator *(decimal number, Time value)
        {
            return new Time(value.Value * number, value.Unit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="power">rigth factor (multiplier)</param>
        public static Energy operator *(Time time, Power power)
        {
            // generator : MultiplyAlgebraGenerator.CreateOperator
            // scenario with hint
            // .Is<Time, Power, Energy>("*")
            // hint location HandleCreateOperatorCode, line 42
            var timeValue = time.GetBaseUnitValue();
            var powerValue = power.GetBaseUnitValue();
            var basicEnergy = timeValue * powerValue;
            var value = basicEnergy;
            return new Energy(value, EnergyUnits.Joule);
            // scenario F3
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="power">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Energy operator *(Power power, Time time)
        {
            // generator : MultiplyAlgebraGenerator.CreateOperator
            // scenario with hint
            // .Is<Power, Time, Energy>("*")
            // hint location HandleCreateOperatorCode, line 51
            var x = 4;
            var powerValue = power.GetBaseUnitValue();
            var timeValue = time.GetBaseUnitValue();
            var basicEnergy = powerValue * timeValue;
            var value = basicEnergy;
            return new Energy(value, EnergyUnits.Joule);
            // scenario F3
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="power">rigth factor (multiplier)</param>
        public static Energy? operator *(Time? time, Power power)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null)
                return null;
            return time.Value * power;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="power">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Energy? operator *(Power? power, Time time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (power is null)
                return null;
            return power.Value * time;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="power">rigth factor (multiplier)</param>
        public static Energy? operator *(Time time, Power? power)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (power is null)
                return null;
            return time * power.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="power">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Energy? operator *(Power power, Time? time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null)
                return null;
            return power * time.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="power">rigth factor (multiplier)</param>
        public static Energy? operator *(Time? time, Power? power)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null || power is null)
                return null;
            return time.Value * power.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="power">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Energy? operator *(Power? power, Time? time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (power is null || time is null)
                return null;
            return power.Value * time.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="velocity">rigth factor (multiplier)</param>
        public static Length operator *(Time time, Velocity velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario B
            var unit = new VelocityUnit(velocity.Unit.CounterUnit, time.Unit);
            var velocityConverted    = velocity.WithDenominatorUnit(time.Unit);
            var value = time.Value * velocityConverted.Value;
            return new Length(value, velocity.Unit.CounterUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="velocity">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Length operator *(Velocity velocity, Time time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // Length operator *(Velocity velocity, Time time)
            // scenario with hint
            // .Is<Velocity, Time, Length>("*")
            // hint location GetBasicOperatorHints, line 31
            var velocityUnit = velocity.Unit;
            var timeConverted = time.ConvertTo(velocityUnit.DenominatorUnit);
            var value = velocity.Value * timeConverted.Value;
            return new Length(value, velocityUnit.CounterUnit);
            // scenario D1
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="velocity">rigth factor (multiplier)</param>
        public static Length? operator *(Time? time, Velocity velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null)
                return null;
            return time.Value * velocity;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="velocity">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Length? operator *(Velocity? velocity, Time time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (velocity is null)
                return null;
            return velocity.Value * time;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="velocity">rigth factor (multiplier)</param>
        public static Length? operator *(Time time, Velocity? velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (velocity is null)
                return null;
            return time * velocity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="velocity">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Length? operator *(Velocity velocity, Time? time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null)
                return null;
            return velocity * time.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="time">left factor (multiplicand)</param>
        /// <param name="velocity">rigth factor (multiplier)</param>
        public static Length? operator *(Time? time, Velocity? velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null || velocity is null)
                return null;
            return time.Value * velocity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="velocity">left factor (multiplicand)</param>
        /// <param name="time">rigth factor (multiplier)</param>
        public static Length? operator *(Velocity? velocity, Time? time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (velocity is null || time is null)
                return null;
            return velocity.Value * time.Value;
        }

        /// <summary>
        /// implements / operator
        /// </summary>
        /// <param name="value"></param>
        /// <param name="number"></param>
        public static Time operator /(Time value, decimal number)
        {
            return new Time(value.Value / number, value.Unit);
        }

        public static decimal operator /(Time left, Time right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_MulDiv
            right = right.ConvertTo(left.Unit);
            return left.Value / right.Value;
        }

        public static Time operator +(Time left, Time right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
            if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
                return right;
            if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
                return left;
            right = right.ConvertTo(left.Unit);
            return new Time(left.Value + right.Value, left.Unit);
        }

        public static bool operator <(Time left, Time right)
        {
            return left.CompareTo(right) < 0;
        }

        public static bool operator <=(Time left, Time right)
        {
            return left.CompareTo(right) <= 0;
        }

        public static bool operator ==(Time left, Time right)
        {
            return left.CompareTo(right) == 0;
        }

        public static bool operator >(Time left, Time right)
        {
            return left.CompareTo(right) > 0;
        }

        public static bool operator >=(Time left, Time right)
        {
            return left.CompareTo(right) >= 0;
        }

        /// <summary>
        /// creates time from value in h
        /// </summary>
        /// <param name="value">Time value in h</param>
        public static Time FromHours(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Hour);
        }

        /// <summary>
        /// creates time from value in h
        /// </summary>
        /// <param name="value">Time value in h</param>
        public static Time FromHours(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time((decimal)value, TimeUnits.Hour);
        }

        /// <summary>
        /// creates time from value in h
        /// </summary>
        /// <param name="value">Time value in h</param>
        public static Time FromHours(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Hour);
        }

        /// <summary>
        /// creates time from value in h
        /// </summary>
        /// <param name="value">Time value in h</param>
        public static Time FromHours(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Hour);
        }

        /// <summary>
        /// creates time from value in ms
        /// </summary>
        /// <param name="value">Time value in ms</param>
        public static Time FromMiliSecond(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.MiliSecond);
        }

        /// <summary>
        /// creates time from value in ms
        /// </summary>
        /// <param name="value">Time value in ms</param>
        public static Time FromMiliSecond(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time((decimal)value, TimeUnits.MiliSecond);
        }

        /// <summary>
        /// creates time from value in ms
        /// </summary>
        /// <param name="value">Time value in ms</param>
        public static Time FromMiliSecond(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.MiliSecond);
        }

        /// <summary>
        /// creates time from value in ms
        /// </summary>
        /// <param name="value">Time value in ms</param>
        public static Time FromMiliSecond(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.MiliSecond);
        }

        /// <summary>
        /// creates time from value in min
        /// </summary>
        /// <param name="value">Time value in min</param>
        public static Time FromMinutes(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Minute);
        }

        /// <summary>
        /// creates time from value in min
        /// </summary>
        /// <param name="value">Time value in min</param>
        public static Time FromMinutes(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time((decimal)value, TimeUnits.Minute);
        }

        /// <summary>
        /// creates time from value in min
        /// </summary>
        /// <param name="value">Time value in min</param>
        public static Time FromMinutes(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Minute);
        }

        /// <summary>
        /// creates time from value in min
        /// </summary>
        /// <param name="value">Time value in min</param>
        public static Time FromMinutes(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Minute);
        }

        /// <summary>
        /// creates time from value in s
        /// </summary>
        /// <param name="value">Time value in s</param>
        public static Time FromSecond(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Second);
        }

        /// <summary>
        /// creates time from value in s
        /// </summary>
        /// <param name="value">Time value in s</param>
        public static Time FromSecond(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time((decimal)value, TimeUnits.Second);
        }

        /// <summary>
        /// creates time from value in s
        /// </summary>
        /// <param name="value">Time value in s</param>
        public static Time FromSecond(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Second);
        }

        /// <summary>
        /// creates time from value in s
        /// </summary>
        /// <param name="value">Time value in s</param>
        public static Time FromSecond(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Second);
        }

        /// <summary>
        /// creates time from value in y
        /// </summary>
        /// <param name="value">Time value in y</param>
        public static Time FromYears(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Year);
        }

        /// <summary>
        /// creates time from value in y
        /// </summary>
        /// <param name="value">Time value in y</param>
        public static Time FromYears(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time((decimal)value, TimeUnits.Year);
        }

        /// <summary>
        /// creates time from value in y
        /// </summary>
        /// <param name="value">Time value in y</param>
        public static Time FromYears(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Year);
        }

        /// <summary>
        /// creates time from value in y
        /// </summary>
        /// <param name="value">Time value in y</param>
        public static Time FromYears(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Time(value, TimeUnits.Year);
        }

        public static Time Parse(string value)
        {
            // generator : BasicUnitValuesGenerator.Add_Parse
            var parseResult = CommonParse.Parse(value, typeof(Time));
            if (string.IsNullOrEmpty(parseResult.UnitName))
                return new Time(parseResult.Value, Time.BaseUnit);
            return new Time(parseResult.Value, new TimeUnit(parseResult.UnitName));
        }

        /// <summary>
        /// value
        /// </summary>
        public decimal Value { get; }

        /// <summary>
        /// unit
        /// </summary>
        [JetBrains.Annotations.NotNull]
        public TimeUnit Unit
        {
            get { return _unit ?? BaseUnit; }
        }

        private TimeUnit _unit;

        public static readonly TimeUnit BaseUnit = TimeUnits.Second;

        public static readonly Time Zero = new Time(0, BaseUnit);

    }

    public static partial class TimeExtensions
    {
        public static Time Sum(this IEnumerable<Time> items)
        {
            if (items is null)
                return Time.Zero;
            var c = items.ToArray();
            if (c.Length == 0)
                return Time.Zero;
            if (c.Length == 1)
                return c[0];
            var unit  = c[0].Unit;
            var value = c.Aggregate(0m, (x, y) => x + y.ConvertTo(unit).Value);
            return new Time(value, unit);
        }

        public static Time Sum(this IEnumerable<Time?> items)
        {
            if (items is null)
                return Time.Zero;
            return items.Where(a => a != null).Select(a => a.Value).Sum();
        }

        public static Time Sum<T>(this IEnumerable<T> items, Func<T, Time> map)
        {
            if (items is null)
                return Time.Zero;
            return items.Select(map).Sum();
        }

    }

    public partial class TimeJsonConverter : AbstractUnitJsonConverter<Time, TimeUnit>
    {
        protected override Time Make(decimal value, string unit)
        {
            unit = unit?.Trim();
            return new Time(value, string.IsNullOrEmpty(unit) ? Time.BaseUnit : new TimeUnit(unit));
        }

        protected override Time Parse(string txt)
        {
            return Time.Parse(txt);
        }

    }
}
