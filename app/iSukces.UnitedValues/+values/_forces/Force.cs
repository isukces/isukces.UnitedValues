using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;

namespace iSukces.UnitedValues;

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: BasicUnitValuesGenerator, UnitJsonConverterGenerator, UnitExtensionsGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator
[Serializable]
[JsonConverter(typeof(ForceJsonConverter))]
public partial struct Force : IUnitedValue<ForceUnit>, IEquatable<Force>, IComparable<Force>, IFormattable
{
    /// <summary>
    /// creates instance of Force
    /// </summary>
    /// <param name="value">value</param>
    /// <param name="unit">unit</param>
    public Force(decimal value, ForceUnit unit)
    {
        Value = value;
        if (unit is null)
            throw new NullReferenceException(nameof(unit));
        _unit = unit;
    }

    public int CompareTo(Force other)
    {
        return UnitedValuesUtils.Compare<Force, ForceUnit>(this, other);
    }

    public Force ConvertTo(ForceUnit newUnit)
    {
        // generator : BasicUnitValuesGenerator.Add_ConvertTo
        if (Unit.Equals(newUnit))
            return this;
        var basic = GetBaseUnitValue();
        var factor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
        return new Force(basic / factor, newUnit);
    }

    public bool Equals(Force other)
    {
        return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
    }

    public bool Equals(IUnitedValue<ForceUnit> other)
    {
        if (other is null)
            return false;
        return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
    }

    public override bool Equals(object other)
    {
        return other is IUnitedValue<ForceUnit> unitedValue ? Equals(unitedValue) : false;
    }

    public decimal GetBaseUnitValue()
    {
        // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
        if (Unit.Equals(BaseUnit))
            return Value;
        var factor = GlobalUnitRegistry.Factors.Get(Unit);
        if (!(factor is null))
            return Value * factor.Value;
        throw new Exception("Unable to find multiplication for unit " + Unit);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
        }
    }

    public Force Round(int decimalPlaces)
    {
        return new Force(Math.Round(Value, decimalPlaces), Unit);
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    public override string ToString()
    {
        return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    /// <param name="format"></param>
    /// <param name="provider"></param>
    public string ToString(string format, IFormatProvider provider = null)
    {
        return this.ToStringFormat(format, provider);
    }

    /// <summary>
    /// implements - operator
    /// </summary>
    /// <param name="value"></param>
    public static Force operator -(Force value)
    {
        return new Force(-value.Value, value.Unit);
    }

    public static Force operator -(Force left, Force right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return -right;
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return left;
        right = right.ConvertTo(left.Unit);
        return new Force(left.Value - right.Value, left.Unit);
    }

    public static bool operator !=(Force left, Force right)
    {
        return left.CompareTo(right) != 0;
    }

    /// <summary>
    /// implements * operator
    /// </summary>
    /// <param name="value"></param>
    /// <param name="number"></param>
    public static Force operator *(Force value, decimal number)
    {
        return new Force(value.Value * number, value.Unit);
    }

    /// <summary>
    /// implements * operator
    /// </summary>
    /// <param name="number"></param>
    /// <param name="value"></param>
    public static Force operator *(decimal number, Force value)
    {
        return new Force(value.Value * number, value.Unit);
    }

    /// <summary>
    /// implements / operator
    /// </summary>
    /// <param name="value"></param>
    /// <param name="number"></param>
    public static Force operator /(Force value, decimal number)
    {
        return new Force(value.Value / number, value.Unit);
    }

    public static decimal operator /(Force left, Force right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_MulDiv
        right = right.ConvertTo(left.Unit);
        return left.Value / right.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearForce operator /(Force force, Length length)
    {
        // generator : MultiplyAlgebraGenerator.CreateOperator
        // scenario with hint
        // hint location HandleCreateOperatorCode, line 19 Def_Force_Length_LinearForce
        var value = force.Value / length.Value;
        return new LinearForce(value, new LinearForceUnit(force.Unit, length.Unit));
        // scenario F3
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearForce">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length operator /(Force force, LinearForce linearForce)
    {
        // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
        // scenario A
        // linearforce unit will be synchronized with force unit
        var unit = new LinearForceUnit(force.Unit, linearForce.Unit.DenominatorUnit);
        var linearForceConverted    = linearForce.WithCounterUnit(force.Unit);
        var value = force.Value / linearForceConverted.Value;
        return new Length(value, linearForce.Unit.DenominatorUnit);
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearForce? operator /(Force? force, Length length)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null)
            return null;
        return force.Value / length;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearForce">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length? operator /(Force? force, LinearForce linearForce)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null)
            return null;
        return force.Value / linearForce;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearForce? operator /(Force force, Length? length)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (length is null)
            return null;
        return force / length.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearForce">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length? operator /(Force force, LinearForce? linearForce)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (linearForce is null)
            return null;
        return force / linearForce.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
    public static LinearForce? operator /(Force? force, Length? length)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null || length is null)
            return null;
        return force.Value / length.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="linearForce">a divisor (denominator) - a value which dividend is divided by</param>
    public static Length? operator /(Force? force, LinearForce? linearForce)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null || linearForce is null)
            return null;
        return force.Value / linearForce.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static Pressure operator /(Force force, Area area)
    {
        // generator : MultiplyAlgebraGenerator.CreateOperator
        // scenario with hint
        // .Is<Force, Area, Pressure>("/")
        // hint location HandleCreateOperatorCode, line 26
        var leftConverted = force.ConvertTo(ForceUnits.Newton);
        var rightConverted = area.ConvertTo(AreaUnits.SquareMeter);
        var value = leftConverted.Value / rightConverted.Value;
        return new Pressure(value, PressureUnits.Pascal);
        // scenario F3
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="pressure">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area operator /(Force force, Pressure pressure)
    {
        // generator : MultiplyAlgebraGenerator.CreateOperator
        // scenario with hint
        // .Is<Force, Pressure, Area>("/")
        // hint location HandleCreateOperatorCode, line 33
        var leftConverted = force.ConvertTo(ForceUnits.Newton);
        var rightConverted = pressure.ConvertTo(PressureUnits.Pascal);
        var value = leftConverted.Value / rightConverted.Value;
        return new Area(value, AreaUnits.SquareMeter);
        // scenario F3
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static Pressure? operator /(Force? force, Area area)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null)
            return null;
        return force.Value / area;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="pressure">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area? operator /(Force? force, Pressure pressure)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null)
            return null;
        return force.Value / pressure;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static Pressure? operator /(Force force, Area? area)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (area is null)
            return null;
        return force / area.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="pressure">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area? operator /(Force force, Pressure? pressure)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (pressure is null)
            return null;
        return force / pressure.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
    public static Pressure? operator /(Force? force, Area? area)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null || area is null)
            return null;
        return force.Value / area.Value;
    }

    /// <summary>
    /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
    /// </summary>
    /// <param name="force">a dividend (counter) - a value that is being divided</param>
    /// <param name="pressure">a divisor (denominator) - a value which dividend is divided by</param>
    public static Area? operator /(Force? force, Pressure? pressure)
    {
        // generator : MultiplyAlgebraGenerator.CreateCode
        if (force is null || pressure is null)
            return null;
        return force.Value / pressure.Value;
    }

    public static Force operator +(Force left, Force right)
    {
        // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
        if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
            return right;
        if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
            return left;
        right = right.ConvertTo(left.Unit);
        return new Force(left.Value + right.Value, left.Unit);
    }

    public static bool operator <(Force left, Force right)
    {
        return left.CompareTo(right) < 0;
    }

    public static bool operator <=(Force left, Force right)
    {
        return left.CompareTo(right) <= 0;
    }

    public static bool operator ==(Force left, Force right)
    {
        return left.CompareTo(right) == 0;
    }

    public static bool operator >(Force left, Force right)
    {
        return left.CompareTo(right) > 0;
    }

    public static bool operator >=(Force left, Force right)
    {
        return left.CompareTo(right) >= 0;
    }

    /// <summary>
    /// creates force from value in kN
    /// </summary>
    /// <param name="value">Force value in kN</param>
    public static Force FromKiloNewton(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.KiloNewton);
    }

    /// <summary>
    /// creates force from value in kN
    /// </summary>
    /// <param name="value">Force value in kN</param>
    public static Force FromKiloNewton(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force((decimal)value, ForceUnits.KiloNewton);
    }

    /// <summary>
    /// creates force from value in kN
    /// </summary>
    /// <param name="value">Force value in kN</param>
    public static Force FromKiloNewton(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.KiloNewton);
    }

    /// <summary>
    /// creates force from value in kN
    /// </summary>
    /// <param name="value">Force value in kN</param>
    public static Force FromKiloNewton(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.KiloNewton);
    }

    /// <summary>
    /// creates force from value in MN
    /// </summary>
    /// <param name="value">Force value in MN</param>
    public static Force FromMegaNewton(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.MegaNewton);
    }

    /// <summary>
    /// creates force from value in MN
    /// </summary>
    /// <param name="value">Force value in MN</param>
    public static Force FromMegaNewton(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force((decimal)value, ForceUnits.MegaNewton);
    }

    /// <summary>
    /// creates force from value in MN
    /// </summary>
    /// <param name="value">Force value in MN</param>
    public static Force FromMegaNewton(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.MegaNewton);
    }

    /// <summary>
    /// creates force from value in MN
    /// </summary>
    /// <param name="value">Force value in MN</param>
    public static Force FromMegaNewton(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.MegaNewton);
    }

    /// <summary>
    /// creates force from value in mN
    /// </summary>
    /// <param name="value">Force value in mN</param>
    public static Force FromMiliNewton(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.MiliNewton);
    }

    /// <summary>
    /// creates force from value in mN
    /// </summary>
    /// <param name="value">Force value in mN</param>
    public static Force FromMiliNewton(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force((decimal)value, ForceUnits.MiliNewton);
    }

    /// <summary>
    /// creates force from value in mN
    /// </summary>
    /// <param name="value">Force value in mN</param>
    public static Force FromMiliNewton(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.MiliNewton);
    }

    /// <summary>
    /// creates force from value in mN
    /// </summary>
    /// <param name="value">Force value in mN</param>
    public static Force FromMiliNewton(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.MiliNewton);
    }

    /// <summary>
    /// creates force from value in N
    /// </summary>
    /// <param name="value">Force value in N</param>
    public static Force FromNewton(decimal value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.Newton);
    }

    /// <summary>
    /// creates force from value in N
    /// </summary>
    /// <param name="value">Force value in N</param>
    public static Force FromNewton(double value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force((decimal)value, ForceUnits.Newton);
    }

    /// <summary>
    /// creates force from value in N
    /// </summary>
    /// <param name="value">Force value in N</param>
    public static Force FromNewton(int value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.Newton);
    }

    /// <summary>
    /// creates force from value in N
    /// </summary>
    /// <param name="value">Force value in N</param>
    public static Force FromNewton(long value)
    {
        // generator : BasicUnitValuesGenerator.Add_FromMethods
        return new Force(value, ForceUnits.Newton);
    }

    public static Force Parse(string value)
    {
        // generator : BasicUnitValuesGenerator.Add_Parse
        var parseResult = CommonParse.Parse(value, typeof(Force));
        if (string.IsNullOrEmpty(parseResult.UnitName))
            return new Force(parseResult.Value, Force.BaseUnit);
        return new Force(parseResult.Value, new ForceUnit(parseResult.UnitName));
    }

    /// <summary>
    /// value
    /// </summary>
    public decimal Value { get; }

    /// <summary>
    /// unit
    /// </summary>
    [JetBrains.Annotations.NotNull]
    public ForceUnit Unit
    {
        get { return _unit ?? BaseUnit; }
    }

    private ForceUnit _unit;

    public static readonly ForceUnit BaseUnit = ForceUnits.Newton;

    public static readonly Force Zero = new Force(0, BaseUnit);

}

public static partial class ForceExtensions
{
    public static Force Sum(this IEnumerable<Force> items)
    {
        if (items is null)
            return Force.Zero;
        var c = items.ToArray();
        if (c.Length == 0)
            return Force.Zero;
        if (c.Length == 1)
            return c[0];
        var unit  = c[0].Unit;
        var value = c.Aggregate(0m, (x, y) => x + y.ConvertTo(unit).Value);
        return new Force(value, unit);
    }

    public static Force Sum(this IEnumerable<Force?> items)
    {
        if (items is null)
            return Force.Zero;
        return items.Where(a => a != null).Select(a => a.Value).Sum();
    }

    public static Force Sum<T>(this IEnumerable<T> items, Func<T, Force> map)
    {
        if (items is null)
            return Force.Zero;
        return items.Select(map).Sum();
    }

}

public partial class ForceJsonConverter : AbstractUnitJsonConverter<Force, ForceUnit>
{
    protected override Force Make(decimal value, string unit)
    {
        unit = unit?.Trim();
        return new Force(value, string.IsNullOrEmpty(unit) ? Force.BaseUnit : new ForceUnit(unit));
    }

    protected override Force Parse(string txt)
    {
        return Force.Parse(txt);
    }

}
