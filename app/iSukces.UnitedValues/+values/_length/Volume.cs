using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: BasicUnitValuesGenerator, UnitJsonConverterGenerator, UnitExtensionsGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator

namespace iSukces.UnitedValues
{
    [Serializable]
    [JsonConverter(typeof(VolumeJsonConverter))]
    public partial struct Volume : IUnitedValue<VolumeUnit>, IEquatable<Volume>, IFormattable
    {
        /// <summary>
        /// creates instance of Volume
        /// </summary>
        /// <param name="value">value</param>
        /// <param name="unit">unit</param>
        public Volume(decimal value, VolumeUnit unit)
        {
            Value = value;
            if (unit is null)
                throw new NullReferenceException(nameof(unit));
            _unit = unit;
        }

        public Volume ConvertTo(VolumeUnit newUnit)
        {
            // generator : BasicUnitValuesGenerator.Add_ConvertTo
            if (Unit.Equals(newUnit))
                return this;
            var basic = GetBaseUnitValue();
            var factor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
            return new Volume(basic / factor, newUnit);
        }

        public bool Equals(Volume other)
        {
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public bool Equals(IUnitedValue<VolumeUnit> other)
        {
            if (other is null)
                return false;
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public override bool Equals(object other)
        {
            return other is IUnitedValue<VolumeUnit> unitedValue ? Equals(unitedValue) : false;
        }

        public decimal GetBaseUnitValue()
        {
            // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
            if (Unit.Equals(BaseUnit))
                return Value;
            var factor = GlobalUnitRegistry.Factors.Get(Unit);
            if (!(factor is null))
                return Value * factor.Value;
            throw new Exception("Unable to find multiplication for unit " + Unit);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
            }
        }

        public Volume Round(int decimalPlaces)
        {
            return new Volume(Math.Round(Value, decimalPlaces), Unit);
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        /// <param name="format"></param>
        /// <param name="provider"></param>
        public string ToString(string format, IFormatProvider provider = null)
        {
            return this.ToStringFormat(format, provider);
        }

        /// <summary>
        /// implements - operator
        /// </summary>
        /// <param name="value"></param>
        public static Volume operator -(Volume value)
        {
            return new Volume(-value.Value, value.Unit);
        }

        public static Volume operator -(Volume left, Volume right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
            if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
                return -right;
            if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
                return left;
            right = right.ConvertTo(left.Unit);
            return new Volume(left.Value - right.Value, left.Unit);
        }

        /// <summary>
        /// implements * operator
        /// </summary>
        /// <param name="value"></param>
        /// <param name="number"></param>
        public static Volume operator *(Volume value, decimal number)
        {
            return new Volume(value.Value * number, value.Unit);
        }

        /// <summary>
        /// implements * operator
        /// </summary>
        /// <param name="number"></param>
        /// <param name="value"></param>
        public static Volume operator *(decimal number, Volume value)
        {
            return new Volume(value.Value * number, value.Unit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="volume">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static Mass operator *(Volume volume, Density density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario B
            var unit = new DensityUnit(density.Unit.CounterUnit, volume.Unit);
            var densityConverted    = density.WithDenominatorUnit(volume.Unit);
            var value = volume.Value * densityConverted.Value;
            return new Mass(value, density.Unit.CounterUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="volume">rigth factor (multiplier)</param>
        public static Mass operator *(Density density, Volume volume)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // Mass operator *(Density density, Volume volume)
            // scenario with hint
            // .Is<Density, Volume, Mass>("*")
            // hint location GetBasicOperatorHints, line 31
            var densityUnit = density.Unit;
            var volumeConverted = volume.ConvertTo(densityUnit.DenominatorUnit);
            var value = density.Value * volumeConverted.Value;
            return new Mass(value, densityUnit.CounterUnit);
            // scenario D1
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="volume">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static Mass? operator *(Volume? volume, Density density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null)
                return null;
            return volume.Value * density;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="volume">rigth factor (multiplier)</param>
        public static Mass? operator *(Density? density, Volume volume)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (density is null)
                return null;
            return density.Value * volume;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="volume">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static Mass? operator *(Volume volume, Density? density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (density is null)
                return null;
            return volume * density.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="volume">rigth factor (multiplier)</param>
        public static Mass? operator *(Density density, Volume? volume)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null)
                return null;
            return density * volume.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="volume">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static Mass? operator *(Volume? volume, Density? density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null || density is null)
                return null;
            return volume.Value * density.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="volume">rigth factor (multiplier)</param>
        public static Mass? operator *(Density? density, Volume? volume)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (density is null || volume is null)
                return null;
            return density.Value * volume.Value;
        }

        /// <summary>
        /// implements / operator
        /// </summary>
        /// <param name="value"></param>
        /// <param name="number"></param>
        public static Volume operator /(Volume value, decimal number)
        {
            return new Volume(value.Value / number, value.Unit);
        }

        public static decimal operator /(Volume left, Volume right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_MulDiv
            right = right.ConvertTo(left.Unit);
            return left.Value / right.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
        public static Length operator /(Volume volume, Area area)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRelatedUnits
            // scenario C
            var rightUnit = GlobalUnitRegistry.Relations.GetOrThrow<VolumeUnit, AreaUnit>(volume.Unit);
            var resultUnit = GlobalUnitRegistry.Relations.GetOrThrow<VolumeUnit, LengthUnit>(volume.Unit);
            var areaConverted = area.ConvertTo(rightUnit);
            var value = volume.Value / areaConverted.Value;
            return new Length(value, resultUnit);
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
        public static Area operator /(Volume volume, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRelatedUnits
            // scenario C
            var rightUnit = GlobalUnitRegistry.Relations.GetOrThrow<VolumeUnit, LengthUnit>(volume.Unit);
            var resultUnit = GlobalUnitRegistry.Relations.GetOrThrow<VolumeUnit, AreaUnit>(volume.Unit);
            var lengthConverted = length.ConvertTo(rightUnit);
            var value = volume.Value / lengthConverted.Value;
            return new Area(value, resultUnit);
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
        public static Length? operator /(Volume? volume, Area area)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null)
                return null;
            return volume.Value / area;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
        public static Area? operator /(Volume? volume, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null)
                return null;
            return volume.Value / length;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
        public static Length? operator /(Volume volume, Area? area)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (area is null)
                return null;
            return volume / area.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
        public static Area? operator /(Volume volume, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return volume / length.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="area">a divisor (denominator) - a value which dividend is divided by</param>
        public static Length? operator /(Volume? volume, Area? area)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null || area is null)
                return null;
            return volume.Value / area.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="volume">a dividend (counter) - a value that is being divided</param>
        /// <param name="length">a divisor (denominator) - a value which dividend is divided by</param>
        public static Area? operator /(Volume? volume, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (volume is null || length is null)
                return null;
            return volume.Value / length.Value;
        }

        public static Volume operator +(Volume left, Volume right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
            if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
                return right;
            if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
                return left;
            right = right.ConvertTo(left.Unit);
            return new Volume(left.Value + right.Value, left.Unit);
        }

        /// <summary>
        /// creates volume from value in cm³
        /// </summary>
        /// <param name="value">Volume value in cm³</param>
        public static Volume FromCubicCentimeters(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicCm);
        }

        /// <summary>
        /// creates volume from value in cm³
        /// </summary>
        /// <param name="value">Volume value in cm³</param>
        public static Volume FromCubicCentimeters(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicCm);
        }

        /// <summary>
        /// creates volume from value in cm³
        /// </summary>
        /// <param name="value">Volume value in cm³</param>
        public static Volume FromCubicCentimeters(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicCm);
        }

        /// <summary>
        /// creates volume from value in cm³
        /// </summary>
        /// <param name="value">Volume value in cm³</param>
        public static Volume FromCubicCentimeters(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicCm);
        }

        /// <summary>
        /// creates volume from value in dm³
        /// </summary>
        /// <param name="value">Volume value in dm³</param>
        public static Volume FromCubicDecimeters(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicDm);
        }

        /// <summary>
        /// creates volume from value in dm³
        /// </summary>
        /// <param name="value">Volume value in dm³</param>
        public static Volume FromCubicDecimeters(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicDm);
        }

        /// <summary>
        /// creates volume from value in dm³
        /// </summary>
        /// <param name="value">Volume value in dm³</param>
        public static Volume FromCubicDecimeters(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicDm);
        }

        /// <summary>
        /// creates volume from value in dm³
        /// </summary>
        /// <param name="value">Volume value in dm³</param>
        public static Volume FromCubicDecimeters(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicDm);
        }

        /// <summary>
        /// creates volume from value in fh³
        /// </summary>
        /// <param name="value">Volume value in fh³</param>
        public static Volume FromCubicFathom(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFathom);
        }

        /// <summary>
        /// creates volume from value in fh³
        /// </summary>
        /// <param name="value">Volume value in fh³</param>
        public static Volume FromCubicFathom(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicFathom);
        }

        /// <summary>
        /// creates volume from value in fh³
        /// </summary>
        /// <param name="value">Volume value in fh³</param>
        public static Volume FromCubicFathom(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFathom);
        }

        /// <summary>
        /// creates volume from value in fh³
        /// </summary>
        /// <param name="value">Volume value in fh³</param>
        public static Volume FromCubicFathom(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFathom);
        }

        /// <summary>
        /// creates volume from value in ft³
        /// </summary>
        /// <param name="value">Volume value in ft³</param>
        public static Volume FromCubicFoot(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFeet);
        }

        /// <summary>
        /// creates volume from value in ft³
        /// </summary>
        /// <param name="value">Volume value in ft³</param>
        public static Volume FromCubicFoot(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicFeet);
        }

        /// <summary>
        /// creates volume from value in ft³
        /// </summary>
        /// <param name="value">Volume value in ft³</param>
        public static Volume FromCubicFoot(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFeet);
        }

        /// <summary>
        /// creates volume from value in ft³
        /// </summary>
        /// <param name="value">Volume value in ft³</param>
        public static Volume FromCubicFoot(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFeet);
        }

        /// <summary>
        /// creates volume from value in fg³
        /// </summary>
        /// <param name="value">Volume value in fg³</param>
        public static Volume FromCubicFurlongs(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFurlong);
        }

        /// <summary>
        /// creates volume from value in fg³
        /// </summary>
        /// <param name="value">Volume value in fg³</param>
        public static Volume FromCubicFurlongs(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicFurlong);
        }

        /// <summary>
        /// creates volume from value in fg³
        /// </summary>
        /// <param name="value">Volume value in fg³</param>
        public static Volume FromCubicFurlongs(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFurlong);
        }

        /// <summary>
        /// creates volume from value in fg³
        /// </summary>
        /// <param name="value">Volume value in fg³</param>
        public static Volume FromCubicFurlongs(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicFurlong);
        }

        /// <summary>
        /// creates volume from value in inch³
        /// </summary>
        /// <param name="value">Volume value in inch³</param>
        public static Volume FromCubicInches(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicInch);
        }

        /// <summary>
        /// creates volume from value in inch³
        /// </summary>
        /// <param name="value">Volume value in inch³</param>
        public static Volume FromCubicInches(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicInch);
        }

        /// <summary>
        /// creates volume from value in inch³
        /// </summary>
        /// <param name="value">Volume value in inch³</param>
        public static Volume FromCubicInches(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicInch);
        }

        /// <summary>
        /// creates volume from value in inch³
        /// </summary>
        /// <param name="value">Volume value in inch³</param>
        public static Volume FromCubicInches(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicInch);
        }

        /// <summary>
        /// creates volume from value in km³
        /// </summary>
        /// <param name="value">Volume value in km³</param>
        public static Volume FromCubicKilometers(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicKm);
        }

        /// <summary>
        /// creates volume from value in km³
        /// </summary>
        /// <param name="value">Volume value in km³</param>
        public static Volume FromCubicKilometers(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicKm);
        }

        /// <summary>
        /// creates volume from value in km³
        /// </summary>
        /// <param name="value">Volume value in km³</param>
        public static Volume FromCubicKilometers(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicKm);
        }

        /// <summary>
        /// creates volume from value in km³
        /// </summary>
        /// <param name="value">Volume value in km³</param>
        public static Volume FromCubicKilometers(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicKm);
        }

        /// <summary>
        /// creates volume from value in m³
        /// </summary>
        /// <param name="value">Volume value in m³</param>
        public static Volume FromCubicMeter(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMeter);
        }

        /// <summary>
        /// creates volume from value in m³
        /// </summary>
        /// <param name="value">Volume value in m³</param>
        public static Volume FromCubicMeter(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicMeter);
        }

        /// <summary>
        /// creates volume from value in m³
        /// </summary>
        /// <param name="value">Volume value in m³</param>
        public static Volume FromCubicMeter(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMeter);
        }

        /// <summary>
        /// creates volume from value in m³
        /// </summary>
        /// <param name="value">Volume value in m³</param>
        public static Volume FromCubicMeter(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMeter);
        }

        /// <summary>
        /// creates volume from value in mil³
        /// </summary>
        /// <param name="value">Volume value in mil³</param>
        public static Volume FromCubicMiles(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMile);
        }

        /// <summary>
        /// creates volume from value in mil³
        /// </summary>
        /// <param name="value">Volume value in mil³</param>
        public static Volume FromCubicMiles(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicMile);
        }

        /// <summary>
        /// creates volume from value in mil³
        /// </summary>
        /// <param name="value">Volume value in mil³</param>
        public static Volume FromCubicMiles(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMile);
        }

        /// <summary>
        /// creates volume from value in mil³
        /// </summary>
        /// <param name="value">Volume value in mil³</param>
        public static Volume FromCubicMiles(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMile);
        }

        /// <summary>
        /// creates volume from value in mm³
        /// </summary>
        /// <param name="value">Volume value in mm³</param>
        public static Volume FromCubicMilimeters(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMm);
        }

        /// <summary>
        /// creates volume from value in mm³
        /// </summary>
        /// <param name="value">Volume value in mm³</param>
        public static Volume FromCubicMilimeters(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicMm);
        }

        /// <summary>
        /// creates volume from value in mm³
        /// </summary>
        /// <param name="value">Volume value in mm³</param>
        public static Volume FromCubicMilimeters(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMm);
        }

        /// <summary>
        /// creates volume from value in mm³
        /// </summary>
        /// <param name="value">Volume value in mm³</param>
        public static Volume FromCubicMilimeters(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicMm);
        }

        /// <summary>
        /// creates volume from value in nm³
        /// </summary>
        /// <param name="value">Volume value in nm³</param>
        public static Volume FromCubicNauticalMiles(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicNauticalMile);
        }

        /// <summary>
        /// creates volume from value in nm³
        /// </summary>
        /// <param name="value">Volume value in nm³</param>
        public static Volume FromCubicNauticalMiles(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicNauticalMile);
        }

        /// <summary>
        /// creates volume from value in nm³
        /// </summary>
        /// <param name="value">Volume value in nm³</param>
        public static Volume FromCubicNauticalMiles(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicNauticalMile);
        }

        /// <summary>
        /// creates volume from value in nm³
        /// </summary>
        /// <param name="value">Volume value in nm³</param>
        public static Volume FromCubicNauticalMiles(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicNauticalMile);
        }

        /// <summary>
        /// creates volume from value in yd³
        /// </summary>
        /// <param name="value">Volume value in yd³</param>
        public static Volume FromCubicYards(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicYard);
        }

        /// <summary>
        /// creates volume from value in yd³
        /// </summary>
        /// <param name="value">Volume value in yd³</param>
        public static Volume FromCubicYards(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume((decimal)value, VolumeUnits.CubicYard);
        }

        /// <summary>
        /// creates volume from value in yd³
        /// </summary>
        /// <param name="value">Volume value in yd³</param>
        public static Volume FromCubicYards(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicYard);
        }

        /// <summary>
        /// creates volume from value in yd³
        /// </summary>
        /// <param name="value">Volume value in yd³</param>
        public static Volume FromCubicYards(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Volume(value, VolumeUnits.CubicYard);
        }

        public static Volume Parse(string value)
        {
            // generator : BasicUnitValuesGenerator.Add_Parse
            var parseResult = CommonParse.Parse(value, typeof(Volume));
            if (string.IsNullOrEmpty(parseResult.UnitName))
                return new Volume(parseResult.Value, Volume.BaseUnit);
            return new Volume(parseResult.Value, new VolumeUnit(parseResult.UnitName));
        }

        /// <summary>
        /// value
        /// </summary>
        public decimal Value { get; }

        /// <summary>
        /// unit
        /// </summary>
        [JetBrains.Annotations.NotNull]
        public VolumeUnit Unit
        {
            get { return _unit ?? BaseUnit; }
        }

        private VolumeUnit _unit;

        public static readonly VolumeUnit BaseUnit = VolumeUnits.CubicMeter;

        public static readonly Volume Zero = new Volume(0, BaseUnit);

    }

    public static partial class VolumeExtensions
    {
        public static Volume Sum(this IEnumerable<Volume> items)
        {
            if (items is null)
                return Volume.Zero;
            var c = items.ToArray();
            if (c.Length == 0)
                return Volume.Zero;
            if (c.Length == 1)
                return c[0];
            var unit  = c[0].Unit;
            var value = c.Aggregate(0m, (x, y) => x + y.ConvertTo(unit).Value);
            return new Volume(value, unit);
        }

        public static Volume Sum(this IEnumerable<Volume?> items)
        {
            if (items is null)
                return Volume.Zero;
            return items.Where(a => a != null).Select(a => a.Value).Sum();
        }

        public static Volume Sum<T>(this IEnumerable<T> items, Func<T, Volume> map)
        {
            if (items is null)
                return Volume.Zero;
            return items.Select(map).Sum();
        }

    }

    public partial class VolumeJsonConverter : AbstractUnitJsonConverter<Volume, VolumeUnit>
    {
        protected override Volume Make(decimal value, string unit)
        {
            unit = unit?.Trim();
            return new Volume(value, string.IsNullOrEmpty(unit) ? Volume.BaseUnit : new VolumeUnit(unit));
        }

        protected override Volume Parse(string txt)
        {
            return Volume.Parse(txt);
        }

    }
}
