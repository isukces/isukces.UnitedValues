using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;

namespace iSukces.UnitedValues
{
    public partial struct Length
    {
        public Length ConvertToMeter()
        {
            return ConvertTo(LengthUnits.Meter);
        }
    }
}

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: BasicUnitValuesGenerator, UnitJsonConverterGenerator, UnitExtensionsGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator, MultiplyAlgebraGenerator

namespace iSukces.UnitedValues
{
    [Serializable]
    [JsonConverter(typeof(LengthJsonConverter))]
    public partial struct Length : IUnitedValue<LengthUnit>, IEquatable<Length>, IComparable<Length>, IFormattable
    {
        /// <summary>
        /// creates instance of Length
        /// </summary>
        /// <param name="value">value</param>
        /// <param name="unit">unit</param>
        public Length(decimal value, LengthUnit unit)
        {
            Value = value;
            if (unit is null)
                throw new NullReferenceException(nameof(unit));
            _unit = unit;
        }

        public int CompareTo(Length other)
        {
            return UnitedValuesUtils.Compare<Length, LengthUnit>(this, other);
        }

        public Length ConvertTo(LengthUnit newUnit)
        {
            // generator : BasicUnitValuesGenerator.Add_ConvertTo
            if (Unit.Equals(newUnit))
                return this;
            var basic = GetBaseUnitValue();
            var factor = GlobalUnitRegistry.Factors.GetThrow(newUnit);
            return new Length(basic / factor, newUnit);
        }

        public bool Equals(Length other)
        {
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public bool Equals(IUnitedValue<LengthUnit> other)
        {
            if (other is null)
                return false;
            return Value == other.Value && !(Unit is null) && Unit.Equals(other.Unit);
        }

        public override bool Equals(object other)
        {
            return other is IUnitedValue<LengthUnit> unitedValue ? Equals(unitedValue) : false;
        }

        public decimal GetBaseUnitValue()
        {
            // generator : BasicUnitValuesGenerator.Add_GetBaseUnitValue
            if (Unit.Equals(BaseUnit))
                return Value;
            var factor = GlobalUnitRegistry.Factors.Get(Unit);
            if (!(factor is null))
                return Value * factor.Value;
            throw new Exception("Unable to find multiplication for unit " + Unit);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Value.GetHashCode() * 397) ^ Unit.GetHashCode();
            }
        }

        public Length Round(int decimalPlaces)
        {
            return new Length(Math.Round(Value, decimalPlaces), Unit);
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        public override string ToString()
        {
            return Value.ToString(CultureInfo.InvariantCulture) + Unit.UnitName;
        }

        /// <summary>
        /// Returns unit name
        /// </summary>
        /// <param name="format"></param>
        /// <param name="provider"></param>
        public string ToString(string format, IFormatProvider provider = null)
        {
            return this.ToStringFormat(format, provider);
        }

        /// <summary>
        /// implements - operator
        /// </summary>
        /// <param name="value"></param>
        public static Length operator -(Length value)
        {
            return new Length(-value.Value, value.Unit);
        }

        public static Length operator -(Length left, Length right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
            if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
                return -right;
            if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
                return left;
            right = right.ConvertTo(left.Unit);
            return new Length(left.Value - right.Value, left.Unit);
        }

        public static bool operator !=(Length left, Length right)
        {
            return left.CompareTo(right) != 0;
        }

        /// <summary>
        /// implements * operator
        /// </summary>
        /// <param name="value"></param>
        /// <param name="number"></param>
        public static Length operator *(Length value, decimal number)
        {
            return new Length(value.Value * number, value.Unit);
        }

        /// <summary>
        /// implements * operator
        /// </summary>
        /// <param name="number"></param>
        /// <param name="value"></param>
        public static Length operator *(decimal number, Length value)
        {
            return new Length(value.Value * number, value.Unit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="leftFactor">left factor (multiplicand)</param>
        /// <param name="rightFactor">rigth factor (multiplier)</param>
        public static Area operator *(Length leftFactor, Length rightFactor)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRelatedUnits
            // scenario C
            var rightUnit = GlobalUnitRegistry.Relations.GetOrThrow<LengthUnit, LengthUnit>(leftFactor.Unit);
            var resultUnit = GlobalUnitRegistry.Relations.GetOrThrow<LengthUnit, AreaUnit>(leftFactor.Unit);
            var rightFactorConverted = rightFactor.ConvertTo(rightUnit);
            var value = leftFactor.Value * rightFactorConverted.Value;
            return new Area(value, resultUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="leftFactor">left factor (multiplicand)</param>
        /// <param name="rightFactor">rigth factor (multiplier)</param>
        public static Area? operator *(Length? leftFactor, Length rightFactor)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (leftFactor is null)
                return null;
            return leftFactor.Value * rightFactor;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="leftFactor">left factor (multiplicand)</param>
        /// <param name="rightFactor">rigth factor (multiplier)</param>
        public static Area? operator *(Length leftFactor, Length? rightFactor)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (rightFactor is null)
                return null;
            return leftFactor * rightFactor.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="leftFactor">left factor (multiplicand)</param>
        /// <param name="rightFactor">rigth factor (multiplier)</param>
        public static Area? operator *(Length? leftFactor, Length? rightFactor)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (leftFactor is null || rightFactor is null)
                return null;
            return leftFactor.Value * rightFactor.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearDensity">rigth factor (multiplier)</param>
        public static Mass operator *(Length length, LinearDensity linearDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario B
            var unit = new LinearDensityUnit(linearDensity.Unit.CounterUnit, length.Unit);
            var linearDensityConverted    = linearDensity.WithDenominatorUnit(length.Unit);
            var value = length.Value * linearDensityConverted.Value;
            return new Mass(value, linearDensity.Unit.CounterUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Mass operator *(LinearDensity linearDensity, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // Mass operator *(LinearDensity linearDensity, Length length)
            // scenario with hint
            // .Is<LinearDensity, Length, Mass>("*")
            // hint location GetBasicOperatorHints, line 31
            var linearDensityUnit = linearDensity.Unit;
            var lengthConverted = length.ConvertTo(linearDensityUnit.DenominatorUnit);
            var value = linearDensity.Value * lengthConverted.Value;
            return new Mass(value, linearDensityUnit.CounterUnit);
            // scenario D1
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearDensity">rigth factor (multiplier)</param>
        public static Mass? operator *(Length? length, LinearDensity linearDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * linearDensity;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Mass? operator *(LinearDensity? linearDensity, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearDensity is null)
                return null;
            return linearDensity.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearDensity">rigth factor (multiplier)</param>
        public static Mass? operator *(Length length, LinearDensity? linearDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearDensity is null)
                return null;
            return length * linearDensity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Mass? operator *(LinearDensity linearDensity, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return linearDensity * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearDensity">rigth factor (multiplier)</param>
        public static Mass? operator *(Length? length, LinearDensity? linearDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || linearDensity is null)
                return null;
            return length.Value * linearDensity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Mass? operator *(LinearDensity? linearDensity, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearDensity is null || length is null)
                return null;
            return linearDensity.Value * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="planarDensity">rigth factor (multiplier)</param>
        public static LinearDensity operator *(Length length, PlanarDensity planarDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario with hint
            // .Is<Length, PlanarDensity, LinearDensity>("*")
            // hint location GetBasicOperatorHints, line 31
            var planarDensityUnit = planarDensity.Unit;
            var tmp1 = planarDensityUnit.CounterUnit;
            var lengthUnit = length.Unit;
            var targetRightUnit = new PlanarDensityUnit(tmp1, lengthUnit.GetAreaUnit());
            var resultUnit = new LinearDensityUnit(tmp1, lengthUnit);
            var planarDensityConverted = planarDensity.ConvertTo(targetRightUnit);
            var value = length.Value * planarDensityConverted.Value;
            return new LinearDensity(value, resultUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="planarDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearDensity operator *(PlanarDensity planarDensity, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // LinearDensity operator *(PlanarDensity planarDensity, Length length)
            // scenario with hint
            // .Is<PlanarDensity, Length, LinearDensity>("*")
            // hint location GetBasicOperatorHints, line 31
            var planarDensityUnit = planarDensity.Unit;
            var tmp1 = planarDensityUnit.DenominatorUnit;
            var tmp2 = tmp1.GetLengthUnit();
            var resultUnit = new LinearDensityUnit(planarDensityUnit.CounterUnit, tmp2);
            var lengthConverted = length.ConvertTo(tmp2);
            var value = planarDensity.Value * lengthConverted.Value;
            return new LinearDensity(value, resultUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="planarDensity">rigth factor (multiplier)</param>
        public static LinearDensity? operator *(Length? length, PlanarDensity planarDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * planarDensity;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="planarDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearDensity? operator *(PlanarDensity? planarDensity, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (planarDensity is null)
                return null;
            return planarDensity.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="planarDensity">rigth factor (multiplier)</param>
        public static LinearDensity? operator *(Length length, PlanarDensity? planarDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (planarDensity is null)
                return null;
            return length * planarDensity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="planarDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearDensity? operator *(PlanarDensity planarDensity, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return planarDensity * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="planarDensity">rigth factor (multiplier)</param>
        public static LinearDensity? operator *(Length? length, PlanarDensity? planarDensity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || planarDensity is null)
                return null;
            return length.Value * planarDensity.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="planarDensity">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearDensity? operator *(PlanarDensity? planarDensity, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (planarDensity is null || length is null)
                return null;
            return planarDensity.Value * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static PlanarDensity operator *(Length length, Density density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario with hint
            // .Is<Length, Density, PlanarDensity>("*")
            // hint location GetBasicOperatorHints, line 31
            var densityUnit = density.Unit;
            var tmp1 = densityUnit.CounterUnit;
            var lengthUnit = length.Unit;
            var targetRightUnit = new DensityUnit(tmp1, lengthUnit.GetVolumeUnit());
            var resultUnit = new PlanarDensityUnit(tmp1, lengthUnit.GetAreaUnit());
            var densityConverted = density.ConvertTo(targetRightUnit);
            var value = length.Value * densityConverted.Value;
            return new PlanarDensity(value, resultUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static PlanarDensity operator *(Density density, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // PlanarDensity operator *(Density density, Length length)
            // scenario with hint
            // .Is<Density, Length, PlanarDensity>("*")
            // hint location GetBasicOperatorHints, line 31
            var densityUnit = density.Unit;
            var tmp1 = densityUnit.DenominatorUnit;
            var resultUnit = new PlanarDensityUnit(densityUnit.CounterUnit, tmp1.GetAreaUnit());
            var lengthConverted = length.ConvertTo(tmp1.GetLengthUnit());
            var value = density.Value * lengthConverted.Value;
            return new PlanarDensity(value, resultUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static PlanarDensity? operator *(Length? length, Density density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * density;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static PlanarDensity? operator *(Density? density, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (density is null)
                return null;
            return density.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static PlanarDensity? operator *(Length length, Density? density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (density is null)
                return null;
            return length * density.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static PlanarDensity? operator *(Density density, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return density * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="density">rigth factor (multiplier)</param>
        public static PlanarDensity? operator *(Length? length, Density? density)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || density is null)
                return null;
            return length.Value * density.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="density">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static PlanarDensity? operator *(Density? density, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (density is null || length is null)
                return null;
            return density.Value * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="pressure">rigth factor (multiplier)</param>
        public static LinearForce operator *(Length length, Pressure pressure)
        {
            // generator : MultiplyAlgebraGenerator.CreateOperator
            // scenario with hint
            // .Is<Length, Pressure, LinearForce>("*")
            // hint location HandleCreateOperatorCode, line 19 Def_LinearForce_Length_Pressure
            var leftConverted = length.ConvertTo(LengthUnits.Meter);
            var rightConverted = pressure.ConvertTo(PressureUnits.Pascal);
            var value = leftConverted.Value * rightConverted.Value;
            return new LinearForce(value, new LinearForceUnit(ForceUnits.Newton, LengthUnits.Meter));
            // scenario F3
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="pressure">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearForce operator *(Pressure pressure, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateOperator
            // scenario with hint
            // .Is<Pressure, Length, LinearForce>("*")
            // hint location HandleCreateOperatorCode, line 35 Def_LinearForce_Length_Pressure
            var leftConverted = pressure.ConvertTo(PressureUnits.Pascal);
            var rightConverted = length.ConvertTo(LengthUnits.Meter);
            var value = leftConverted.Value * rightConverted.Value;
            return new LinearForce(value, new LinearForceUnit(ForceUnits.Newton, LengthUnits.Meter));
            // scenario F3
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="pressure">rigth factor (multiplier)</param>
        public static LinearForce? operator *(Length? length, Pressure pressure)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * pressure;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="pressure">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearForce? operator *(Pressure? pressure, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (pressure is null)
                return null;
            return pressure.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="pressure">rigth factor (multiplier)</param>
        public static LinearForce? operator *(Length length, Pressure? pressure)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (pressure is null)
                return null;
            return length * pressure.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="pressure">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearForce? operator *(Pressure pressure, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return pressure * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="pressure">rigth factor (multiplier)</param>
        public static LinearForce? operator *(Length? length, Pressure? pressure)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || pressure is null)
                return null;
            return length.Value * pressure.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="pressure">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearForce? operator *(Pressure? pressure, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (pressure is null || length is null)
                return null;
            return pressure.Value * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearForce">rigth factor (multiplier)</param>
        public static Force operator *(Length length, LinearForce linearForce)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario B
            var unit = new LinearForceUnit(linearForce.Unit.CounterUnit, length.Unit);
            var linearForceConverted    = linearForce.WithDenominatorUnit(length.Unit);
            var value = length.Value * linearForceConverted.Value;
            return new Force(value, linearForce.Unit.CounterUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearForce">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Force operator *(LinearForce linearForce, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // Force operator *(LinearForce linearForce, Length length)
            // scenario with hint
            // hint location HandleCreateOperatorCode, line 28 Def_Force_Length_LinearForce
            var lengthConverted = length.ConvertTo(linearForce.Unit.DenominatorUnit);
            var value = linearForce.Value * lengthConverted.Value;
            return new Force(value, linearForce.Unit.CounterUnit);
            // scenario D1
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearForce">rigth factor (multiplier)</param>
        public static Force? operator *(Length? length, LinearForce linearForce)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * linearForce;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearForce">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Force? operator *(LinearForce? linearForce, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearForce is null)
                return null;
            return linearForce.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearForce">rigth factor (multiplier)</param>
        public static Force? operator *(Length length, LinearForce? linearForce)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearForce is null)
                return null;
            return length * linearForce.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearForce">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Force? operator *(LinearForce linearForce, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return linearForce * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearForce">rigth factor (multiplier)</param>
        public static Force? operator *(Length? length, LinearForce? linearForce)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || linearForce is null)
                return null;
            return length.Value * linearForce.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearForce">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Force? operator *(LinearForce? linearForce, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearForce is null || length is null)
                return null;
            return linearForce.Value * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearPowerLoss">rigth factor (multiplier)</param>
        public static Power operator *(Length length, LinearPowerLoss linearPowerLoss)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario B
            var unit = new LinearPowerLossUnit(linearPowerLoss.Unit.CounterUnit, length.Unit);
            var linearPowerLossConverted    = linearPowerLoss.WithDenominatorUnit(length.Unit);
            var value = length.Value * linearPowerLossConverted.Value;
            return new Power(value, linearPowerLoss.Unit.CounterUnit);
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearPowerLoss">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Power operator *(LinearPowerLoss linearPowerLoss, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // Power operator *(LinearPowerLoss linearPowerLoss, Length length)
            // scenario with hint
            // hint location HandleCreateOperatorCode, line 34 Def_Power_Length_LinearPowerLoss
            var tmp = linearPowerLoss.Unit;
            var resultUnit = tmp.CounterUnit;
            var lengthUnit = tmp.DenominatorUnit;
            var lengthConverted = length.ConvertTo(lengthUnit);
            var value = linearPowerLoss.Value * lengthConverted.Value;
            return new Power(value, resultUnit);
            // scenario D1
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearPowerLoss">rigth factor (multiplier)</param>
        public static Power? operator *(Length? length, LinearPowerLoss linearPowerLoss)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * linearPowerLoss;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearPowerLoss">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Power? operator *(LinearPowerLoss? linearPowerLoss, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearPowerLoss is null)
                return null;
            return linearPowerLoss.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearPowerLoss">rigth factor (multiplier)</param>
        public static Power? operator *(Length length, LinearPowerLoss? linearPowerLoss)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearPowerLoss is null)
                return null;
            return length * linearPowerLoss.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearPowerLoss">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Power? operator *(LinearPowerLoss linearPowerLoss, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return linearPowerLoss * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="linearPowerLoss">rigth factor (multiplier)</param>
        public static Power? operator *(Length? length, LinearPowerLoss? linearPowerLoss)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || linearPowerLoss is null)
                return null;
            return length.Value * linearPowerLoss.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="linearPowerLoss">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static Power? operator *(LinearPowerLoss? linearPowerLoss, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (linearPowerLoss is null || length is null)
                return null;
            return linearPowerLoss.Value * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="irradiance">rigth factor (multiplier)</param>
        public static LinearPowerLoss operator *(Length length, Irradiance irradiance)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario with hint
            // hint location HandleCreateOperatorCode, line 65 Def_LinearPowerLoss_Length_Irradiance
            var areaUnit = length.Unit.GetAreaUnit();
            var irradianceConverted = irradiance.WithDenominatorUnit(areaUnit);
            var value = length.Value * irradianceConverted.Value;
            return new LinearPowerLoss(value, new LinearPowerLossUnit(irradiance.Unit.CounterUnit, length.Unit));
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="irradiance">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearPowerLoss operator *(Irradiance irradiance, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForLeftFractionValue
            // LinearPowerLoss operator *(Irradiance irradiance, Length length)
            // scenario with hint
            // hint location HandleCreateOperatorCode, line 55 Def_LinearPowerLoss_Length_Irradiance
            var lengthConverted = length.ConvertTo(irradiance.Unit.DenominatorUnit.GetLengthUnit());
            var value = irradiance.Value * lengthConverted.Value;
            return new LinearPowerLoss(value, new LinearPowerLossUnit(irradiance.Unit.CounterUnit, lengthConverted.Unit));
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="irradiance">rigth factor (multiplier)</param>
        public static LinearPowerLoss? operator *(Length? length, Irradiance irradiance)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value * irradiance;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="irradiance">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearPowerLoss? operator *(Irradiance? irradiance, Length length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (irradiance is null)
                return null;
            return irradiance.Value * length;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="irradiance">rigth factor (multiplier)</param>
        public static LinearPowerLoss? operator *(Length length, Irradiance? irradiance)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (irradiance is null)
                return null;
            return length * irradiance.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="irradiance">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearPowerLoss? operator *(Irradiance irradiance, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return irradiance * length.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="length">left factor (multiplicand)</param>
        /// <param name="irradiance">rigth factor (multiplier)</param>
        public static LinearPowerLoss? operator *(Length? length, Irradiance? irradiance)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || irradiance is null)
                return null;
            return length.Value * irradiance.Value;
        }

        /// <summary>
        /// Multiplication operation
        /// </summary>
        /// <param name="irradiance">left factor (multiplicand)</param>
        /// <param name="length">rigth factor (multiplier)</param>
        public static LinearPowerLoss? operator *(Irradiance? irradiance, Length? length)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (irradiance is null || length is null)
                return null;
            return irradiance.Value * length.Value;
        }

        /// <summary>
        /// implements / operator
        /// </summary>
        /// <param name="value"></param>
        /// <param name="number"></param>
        public static Length operator /(Length value, decimal number)
        {
            return new Length(value.Value / number, value.Unit);
        }

        public static decimal operator /(Length left, Length right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_MulDiv
            right = right.ConvertTo(left.Unit);
            return left.Value / right.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="time">a divisor (denominator) - a value which dividend is divided by</param>
        public static Velocity operator /(Length length, Time time)
        {
            // generator : MultiplyAlgebraGenerator.CreateOperator
            // scenario with hint
            // .Is<Length, Time, Velocity>("/")
            // hint location GetBasicOperatorHints, line 31
            var resultUnit = new VelocityUnit(length.Unit, time.Unit);
            var value = length.Value / time.Value;
            return new Velocity(value, resultUnit);
            // scenario F3
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="velocity">a divisor (denominator) - a value which dividend is divided by</param>
        public static Time operator /(Length length, Velocity velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCodeForRightFractionValue
            // scenario A
            // velocity unit will be synchronized with length unit
            var unit = new VelocityUnit(length.Unit, velocity.Unit.DenominatorUnit);
            var velocityConverted    = velocity.WithCounterUnit(length.Unit);
            var value = length.Value / velocityConverted.Value;
            return new Time(value, velocity.Unit.DenominatorUnit);
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="time">a divisor (denominator) - a value which dividend is divided by</param>
        public static Velocity? operator /(Length? length, Time time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value / time;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="velocity">a divisor (denominator) - a value which dividend is divided by</param>
        public static Time? operator /(Length? length, Velocity velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null)
                return null;
            return length.Value / velocity;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="time">a divisor (denominator) - a value which dividend is divided by</param>
        public static Velocity? operator /(Length length, Time? time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (time is null)
                return null;
            return length / time.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="velocity">a divisor (denominator) - a value which dividend is divided by</param>
        public static Time? operator /(Length length, Velocity? velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (velocity is null)
                return null;
            return length / velocity.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="time">a divisor (denominator) - a value which dividend is divided by</param>
        public static Velocity? operator /(Length? length, Time? time)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || time is null)
                return null;
            return length.Value / time.Value;
        }

        /// <summary>
        /// Division operation, calculates value dividend/divisor with unit that derives from dividend unit
        /// </summary>
        /// <param name="length">a dividend (counter) - a value that is being divided</param>
        /// <param name="velocity">a divisor (denominator) - a value which dividend is divided by</param>
        public static Time? operator /(Length? length, Velocity? velocity)
        {
            // generator : MultiplyAlgebraGenerator.CreateCode
            if (length is null || velocity is null)
                return null;
            return length.Value / velocity.Value;
        }

        public static Length operator +(Length left, Length right)
        {
            // generator : BasicUnitValuesGenerator.Add_Algebra_PlusMinus
            if (left.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(left.Unit?.UnitName))
                return right;
            if (right.Value.Equals(decimal.Zero) && string.IsNullOrEmpty(right.Unit?.UnitName))
                return left;
            right = right.ConvertTo(left.Unit);
            return new Length(left.Value + right.Value, left.Unit);
        }

        public static bool operator <(Length left, Length right)
        {
            return left.CompareTo(right) < 0;
        }

        public static bool operator <=(Length left, Length right)
        {
            return left.CompareTo(right) <= 0;
        }

        public static bool operator ==(Length left, Length right)
        {
            return left.CompareTo(right) == 0;
        }

        public static bool operator >(Length left, Length right)
        {
            return left.CompareTo(right) > 0;
        }

        public static bool operator >=(Length left, Length right)
        {
            return left.CompareTo(right) >= 0;
        }

        /// <summary>
        /// creates length from value in cm
        /// </summary>
        /// <param name="value">Length value in cm</param>
        public static Length FromCentimeters(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Cm);
        }

        /// <summary>
        /// creates length from value in cm
        /// </summary>
        /// <param name="value">Length value in cm</param>
        public static Length FromCentimeters(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Cm);
        }

        /// <summary>
        /// creates length from value in cm
        /// </summary>
        /// <param name="value">Length value in cm</param>
        public static Length FromCentimeters(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Cm);
        }

        /// <summary>
        /// creates length from value in cm
        /// </summary>
        /// <param name="value">Length value in cm</param>
        public static Length FromCentimeters(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Cm);
        }

        /// <summary>
        /// creates length from value in dm
        /// </summary>
        /// <param name="value">Length value in dm</param>
        public static Length FromDecimeters(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Dm);
        }

        /// <summary>
        /// creates length from value in dm
        /// </summary>
        /// <param name="value">Length value in dm</param>
        public static Length FromDecimeters(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Dm);
        }

        /// <summary>
        /// creates length from value in dm
        /// </summary>
        /// <param name="value">Length value in dm</param>
        public static Length FromDecimeters(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Dm);
        }

        /// <summary>
        /// creates length from value in dm
        /// </summary>
        /// <param name="value">Length value in dm</param>
        public static Length FromDecimeters(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Dm);
        }

        /// <summary>
        /// creates length from value in fh
        /// </summary>
        /// <param name="value">Length value in fh</param>
        public static Length FromFathom(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Fathom);
        }

        /// <summary>
        /// creates length from value in fh
        /// </summary>
        /// <param name="value">Length value in fh</param>
        public static Length FromFathom(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Fathom);
        }

        /// <summary>
        /// creates length from value in fh
        /// </summary>
        /// <param name="value">Length value in fh</param>
        public static Length FromFathom(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Fathom);
        }

        /// <summary>
        /// creates length from value in fh
        /// </summary>
        /// <param name="value">Length value in fh</param>
        public static Length FromFathom(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Fathom);
        }

        /// <summary>
        /// creates length from value in ft
        /// </summary>
        /// <param name="value">Length value in ft</param>
        public static Length FromFoot(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Feet);
        }

        /// <summary>
        /// creates length from value in ft
        /// </summary>
        /// <param name="value">Length value in ft</param>
        public static Length FromFoot(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Feet);
        }

        /// <summary>
        /// creates length from value in ft
        /// </summary>
        /// <param name="value">Length value in ft</param>
        public static Length FromFoot(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Feet);
        }

        /// <summary>
        /// creates length from value in ft
        /// </summary>
        /// <param name="value">Length value in ft</param>
        public static Length FromFoot(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Feet);
        }

        /// <summary>
        /// creates length from value in fg
        /// </summary>
        /// <param name="value">Length value in fg</param>
        public static Length FromFurlongs(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Furlong);
        }

        /// <summary>
        /// creates length from value in fg
        /// </summary>
        /// <param name="value">Length value in fg</param>
        public static Length FromFurlongs(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Furlong);
        }

        /// <summary>
        /// creates length from value in fg
        /// </summary>
        /// <param name="value">Length value in fg</param>
        public static Length FromFurlongs(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Furlong);
        }

        /// <summary>
        /// creates length from value in fg
        /// </summary>
        /// <param name="value">Length value in fg</param>
        public static Length FromFurlongs(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Furlong);
        }

        /// <summary>
        /// creates length from value in inch
        /// </summary>
        /// <param name="value">Length value in inch</param>
        public static Length FromInches(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Inch);
        }

        /// <summary>
        /// creates length from value in inch
        /// </summary>
        /// <param name="value">Length value in inch</param>
        public static Length FromInches(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Inch);
        }

        /// <summary>
        /// creates length from value in inch
        /// </summary>
        /// <param name="value">Length value in inch</param>
        public static Length FromInches(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Inch);
        }

        /// <summary>
        /// creates length from value in inch
        /// </summary>
        /// <param name="value">Length value in inch</param>
        public static Length FromInches(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Inch);
        }

        /// <summary>
        /// creates length from value in km
        /// </summary>
        /// <param name="value">Length value in km</param>
        public static Length FromKilometers(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Km);
        }

        /// <summary>
        /// creates length from value in km
        /// </summary>
        /// <param name="value">Length value in km</param>
        public static Length FromKilometers(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Km);
        }

        /// <summary>
        /// creates length from value in km
        /// </summary>
        /// <param name="value">Length value in km</param>
        public static Length FromKilometers(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Km);
        }

        /// <summary>
        /// creates length from value in km
        /// </summary>
        /// <param name="value">Length value in km</param>
        public static Length FromKilometers(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Km);
        }

        /// <summary>
        /// creates length from value in m
        /// </summary>
        /// <param name="value">Length value in m</param>
        public static Length FromMeter(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Meter);
        }

        /// <summary>
        /// creates length from value in m
        /// </summary>
        /// <param name="value">Length value in m</param>
        public static Length FromMeter(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Meter);
        }

        /// <summary>
        /// creates length from value in m
        /// </summary>
        /// <param name="value">Length value in m</param>
        public static Length FromMeter(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Meter);
        }

        /// <summary>
        /// creates length from value in m
        /// </summary>
        /// <param name="value">Length value in m</param>
        public static Length FromMeter(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Meter);
        }

        /// <summary>
        /// creates length from value in mil
        /// </summary>
        /// <param name="value">Length value in mil</param>
        public static Length FromMiles(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Mile);
        }

        /// <summary>
        /// creates length from value in mil
        /// </summary>
        /// <param name="value">Length value in mil</param>
        public static Length FromMiles(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Mile);
        }

        /// <summary>
        /// creates length from value in mil
        /// </summary>
        /// <param name="value">Length value in mil</param>
        public static Length FromMiles(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Mile);
        }

        /// <summary>
        /// creates length from value in mil
        /// </summary>
        /// <param name="value">Length value in mil</param>
        public static Length FromMiles(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Mile);
        }

        /// <summary>
        /// creates length from value in mm
        /// </summary>
        /// <param name="value">Length value in mm</param>
        public static Length FromMilimeters(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Mm);
        }

        /// <summary>
        /// creates length from value in mm
        /// </summary>
        /// <param name="value">Length value in mm</param>
        public static Length FromMilimeters(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Mm);
        }

        /// <summary>
        /// creates length from value in mm
        /// </summary>
        /// <param name="value">Length value in mm</param>
        public static Length FromMilimeters(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Mm);
        }

        /// <summary>
        /// creates length from value in mm
        /// </summary>
        /// <param name="value">Length value in mm</param>
        public static Length FromMilimeters(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Mm);
        }

        /// <summary>
        /// creates length from value in nm
        /// </summary>
        /// <param name="value">Length value in nm</param>
        public static Length FromNauticalMiles(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.NauticalMile);
        }

        /// <summary>
        /// creates length from value in nm
        /// </summary>
        /// <param name="value">Length value in nm</param>
        public static Length FromNauticalMiles(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.NauticalMile);
        }

        /// <summary>
        /// creates length from value in nm
        /// </summary>
        /// <param name="value">Length value in nm</param>
        public static Length FromNauticalMiles(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.NauticalMile);
        }

        /// <summary>
        /// creates length from value in nm
        /// </summary>
        /// <param name="value">Length value in nm</param>
        public static Length FromNauticalMiles(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.NauticalMile);
        }

        /// <summary>
        /// creates length from value in yd
        /// </summary>
        /// <param name="value">Length value in yd</param>
        public static Length FromYards(decimal value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Yard);
        }

        /// <summary>
        /// creates length from value in yd
        /// </summary>
        /// <param name="value">Length value in yd</param>
        public static Length FromYards(double value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length((decimal)value, LengthUnits.Yard);
        }

        /// <summary>
        /// creates length from value in yd
        /// </summary>
        /// <param name="value">Length value in yd</param>
        public static Length FromYards(int value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Yard);
        }

        /// <summary>
        /// creates length from value in yd
        /// </summary>
        /// <param name="value">Length value in yd</param>
        public static Length FromYards(long value)
        {
            // generator : BasicUnitValuesGenerator.Add_FromMethods
            return new Length(value, LengthUnits.Yard);
        }

        public static Length Parse(string value)
        {
            // generator : BasicUnitValuesGenerator.Add_Parse
            var parseResult = CommonParse.Parse(value, typeof(Length));
            if (string.IsNullOrEmpty(parseResult.UnitName))
                return new Length(parseResult.Value, Length.BaseUnit);
            return new Length(parseResult.Value, new LengthUnit(parseResult.UnitName));
        }

        /// <summary>
        /// value
        /// </summary>
        public decimal Value { get; }

        /// <summary>
        /// unit
        /// </summary>
        [JetBrains.Annotations.NotNull]
        public LengthUnit Unit
        {
            get { return _unit ?? BaseUnit; }
        }

        private LengthUnit _unit;

        public static readonly LengthUnit BaseUnit = LengthUnits.Meter;

        public static readonly Length Zero = new Length(0, BaseUnit);

    }

    public static partial class LengthExtensions
    {
        public static Length Sum(this IEnumerable<Length> items)
        {
            if (items is null)
                return Length.Zero;
            var c = items.ToArray();
            if (c.Length == 0)
                return Length.Zero;
            if (c.Length == 1)
                return c[0];
            var unit  = c[0].Unit;
            var value = c.Aggregate(0m, (x, y) => x + y.ConvertTo(unit).Value);
            return new Length(value, unit);
        }

        public static Length Sum(this IEnumerable<Length?> items)
        {
            if (items is null)
                return Length.Zero;
            return items.Where(a => a != null).Select(a => a.Value).Sum();
        }

        public static Length Sum<T>(this IEnumerable<T> items, Func<T, Length> map)
        {
            if (items is null)
                return Length.Zero;
            return items.Select(map).Sum();
        }

    }

    public partial class LengthJsonConverter : AbstractUnitJsonConverter<Length, LengthUnit>
    {
        protected override Length Make(decimal value, string unit)
        {
            unit = unit?.Trim();
            return new Length(value, string.IsNullOrEmpty(unit) ? Length.BaseUnit : new LengthUnit(unit));
        }

        protected override Length Parse(string txt)
        {
            return Length.Parse(txt);
        }

    }
}
