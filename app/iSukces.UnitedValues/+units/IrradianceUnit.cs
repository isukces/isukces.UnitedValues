using System;
using System.Collections.Generic;

namespace iSukces.UnitedValues;

public sealed partial class IrradianceUnit
{
}

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: FractionUnitGenerator
public sealed partial class IrradianceUnit : IFractionalUnit<PowerUnit, AreaUnit>, IEquatable<IrradianceUnit>, IDecomposableUnit
{
    /// <summary>
    /// creates instance of IrradianceUnit
    /// </summary>
    /// <param name="counterUnit">counter unit</param>
    /// <param name="denominatorUnit">denominator unit</param>
    public IrradianceUnit(PowerUnit counterUnit, AreaUnit denominatorUnit)
    {
        CounterUnit = counterUnit;
        DenominatorUnit = denominatorUnit;
    }

    public IReadOnlyList<DecomposableUnitItem> Decompose()
    {
        // generator : FractionUnitGenerator.Add_Decompose
        var denominatorUnit = DenominatorUnit.GetBasicUnit();
        return new []
        {
            new DecomposableUnitItem(CounterUnit, 1),
            new DecomposableUnitItem(denominatorUnit.Unit, -denominatorUnit.Power)
        };
        /*
        var decomposer = new UnitDecomposer();
        decomposer.Add(CounterUnit, 1);
        decomposer.Add(DenominatorUnit, -1);
        return decomposer.Items;
        */
    }

    public bool Equals(IrradianceUnit? other)
    {
        // generator : FractionUnitGenerator
        return CounterUnit.Equals(other?.CounterUnit) && DenominatorUnit.Equals(other?.DenominatorUnit);
    }

    public override bool Equals(object? other)
    {
        // generator : FractionUnitGenerator
        return other is IrradianceUnit value && Equals(value);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (CounterUnit.GetHashCode() * 397) ^ DenominatorUnit.GetHashCode();
        }
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    public override string ToString()
    {
        return UnitName;
    }

    public IrradianceUnit WithCounterUnit(PowerUnit newUnit)
    {
        // generator : FractionUnitGenerator.Add_WithSecond
        return new IrradianceUnit(newUnit, DenominatorUnit);
    }

    public IrradianceUnit WithDenominatorUnit(AreaUnit newUnit)
    {
        // generator : FractionUnitGenerator.Add_WithFirst
        return new IrradianceUnit(CounterUnit, newUnit);
    }

    /// <summary>
    /// Inequality operator
    /// </summary>
    /// <param name="left">first value to compare</param>
    /// <param name="right">second value to compare</param>
    public static bool operator !=(IrradianceUnit left, IrradianceUnit right)
    {
        return !left.Equals(right);
    }

    /// <summary>
    /// Equality operator
    /// </summary>
    /// <param name="left">first value to compare</param>
    /// <param name="right">second value to compare</param>
    public static bool operator ==(IrradianceUnit left, IrradianceUnit right)
    {
        return left.Equals(right);
    }

    /// <summary>
    /// counter unit
    /// </summary>
    public PowerUnit CounterUnit { get; }

    /// <summary>
    /// denominator unit
    /// </summary>
    public AreaUnit DenominatorUnit { get; }

    public string UnitName => CounterUnit.UnitName + "/" + DenominatorUnit.UnitName;

}
