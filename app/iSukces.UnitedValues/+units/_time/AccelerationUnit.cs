using System;
using System.Collections.Generic;

namespace iSukces.UnitedValues;

// -----===== autogenerated code =====-----
// ReSharper disable All
// generator: FractionUnitGenerator, CommonFractionalUnitsGenerator
public sealed partial class AccelerationUnit : IFractionalUnit<LengthUnit, SquareTimeUnit>, IEquatable<AccelerationUnit>, IDecomposableUnit
{
    /// <summary>
    /// creates instance of AccelerationUnit
    /// </summary>
    /// <param name="counterUnit">counter unit</param>
    /// <param name="denominatorUnit">denominator unit</param>
    public AccelerationUnit(LengthUnit counterUnit, SquareTimeUnit denominatorUnit)
    {
        CounterUnit = counterUnit;
        DenominatorUnit = denominatorUnit;
    }

    public IReadOnlyList<DecomposableUnitItem> Decompose()
    {
        // generator : FractionUnitGenerator.Add_Decompose
        var denominatorUnit = DenominatorUnit.GetBasicUnit();
        return new []
        {
            new DecomposableUnitItem(CounterUnit, 1),
            new DecomposableUnitItem(denominatorUnit.Unit, -denominatorUnit.Power)
        };
        /*
        var decomposer = new UnitDecomposer();
        decomposer.Add(CounterUnit, 1);
        decomposer.Add(DenominatorUnit, -1);
        return decomposer.Items;
        */
    }

    public bool Equals(AccelerationUnit? other)
    {
        // generator : FractionUnitGenerator
        return CounterUnit.Equals(other?.CounterUnit) && DenominatorUnit.Equals(other?.DenominatorUnit);
    }

    public override bool Equals(object? other)
    {
        // generator : FractionUnitGenerator
        return other is AccelerationUnit value && Equals(value);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (CounterUnit.GetHashCode() * 397) ^ DenominatorUnit.GetHashCode();
        }
    }

    /// <summary>
    /// Returns unit name
    /// </summary>
    public override string ToString()
    {
        return UnitName;
    }

    public AccelerationUnit WithCounterUnit(LengthUnit newUnit)
    {
        // generator : FractionUnitGenerator.Add_WithSecond
        return new AccelerationUnit(newUnit, DenominatorUnit);
    }

    public AccelerationUnit WithDenominatorUnit(SquareTimeUnit newUnit)
    {
        // generator : FractionUnitGenerator.Add_WithFirst
        return new AccelerationUnit(CounterUnit, newUnit);
    }

    /// <summary>
    /// Equality operator
    /// </summary>
    /// <param name="left">first value to compare</param>
    /// <param name="right">second value to compare</param>
    public static bool operator ==(AccelerationUnit left, AccelerationUnit right)
    {
        return left.Equals(right);
    }

    /// <summary>
    /// Inequality operator
    /// </summary>
    /// <param name="left">first value to compare</param>
    /// <param name="right">second value to compare</param>
    public static bool operator !=(AccelerationUnit left, AccelerationUnit right)
    {
        return !left.Equals(right);
    }

    /// <summary>
    /// counter unit
    /// </summary>
    public LengthUnit CounterUnit { get; }

    /// <summary>
    /// denominator unit
    /// </summary>
    public SquareTimeUnit DenominatorUnit { get; }

    public string UnitName => CounterUnit.UnitName + "/" + DenominatorUnit.UnitName;

}

// Type=ValueTypeName=Acceleration, UnitTypeName=AccelerationUnit, UnitContainerTypeName=AccelerationUnits, CounterUnit=Meter, DenominatorUnit=SquareSecond, TargetPropertyName=MetersPerSquareSeconds
public partial class AccelerationUnits
{
    /// <summary>
    /// represents acceleration unit 'm/sÂ²'
    /// </summary>
    public static readonly AccelerationUnit MetersPerSquareSeconds = new AccelerationUnit(LengthUnits.Meter, SquareTimeUnits.SquareSecond);

}
